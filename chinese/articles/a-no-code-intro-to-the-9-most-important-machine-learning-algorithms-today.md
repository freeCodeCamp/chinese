> -   原文地址：[9 Key Machine Learning Algorithms Explained in Plain English](https://www.freecodecamp.org/news/a-no-code-intro-to-the-9-most-important-machine-learning-algorithms-today/)
> -   原文作者：Nick McCullum
> -   译者：michaelhe545
> -   校对者：

![通俗讲解之9个核心机器学习算法](https://images.unsplash.com/photo-1504639725590-34d0984388bd?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ)

如今，[机器学习][1]  正改变着我们的世界。借助机器学习（ML），谷歌在为我们推荐搜索结果，奈飞在为我们推荐观看影片，脸书在为我们推荐可能认识的朋友。

机器学习从未像在今天这样重要。但与此同时，机器学习这一领域也充斥着各种术语，晦涩难懂，各种机器学习的算法每年层出不穷。

本篇文章将向您介绍机器学习领域的基础概念。更确切地说，我们将讨论时下 9 大核心机器学习算法背后的基本概念。

# 推荐系统

### 什么是推荐系统？

[推荐系统][2]  的用途在于在一个数据集中寻找相似的条目。

推荐系统在现实世界最常见的应用莫过于奈飞的影视推荐。具体而言，奈飞在向你提供视频在线观看服务时，会根据你已经观看过的内容向你推荐其它影片或电视剧集。

另一个应用实例是脸书“你可能认识的人”这一功能，这一功能会根据你当前的好友列表来向你推荐你可能认识的朋友。

这些开发完善、部署精密的推荐系统内部都十分复杂，且极具消耗数字资源。

### 推荐系统和线性代数

要想从零开始构建一个完善的推荐系统，就需要对线性代数有深刻掌握。

也正因如此，如果你此前并未学习过线性代数，本节可能会出现一些你尚不理解的概念。

但别担心，scikit-learn Python 图书馆已让构建推荐系统变得非常容易。换句话说，即便你没有很深厚的线性代数背景，你也可以在现实世界中构建出一个推荐系统。

### 推荐系统的工作原理是什么呢？

推荐系统主要分为两类：

-   基于内容的推荐系统
-   协同过滤推荐系统

基于内容的推荐系统在做出推荐时根据的是某条目同已使用条目之间的相似性，这同大众关于推荐系统原理的普遍认知相一致。

协同过滤推荐系统在做出推荐时根据的则是用户同条目互动的知识。从命名上就有所不同的这类系统利用的是一群人的智慧。（这也是其命名中“协同”一词的内涵。）

在现实生活中，协同过滤推荐系统要远比基于内容的推荐系统更加常见。原因主要在于协同过滤推荐系统的推荐结果更准确。此外，一些业内人士也表示协同过滤推荐系统要更易于理解。

协同过滤推荐系统也有一项基于内容的推荐系统所不具备的功能。那就是，它们能够自主学习功能。

也就是说，它们甚至能够依据一些你事先并未设定的属性来展开条目间相似性的识别。

协同过滤推荐系统下又细分两个子类别：

-   基于记忆的协同过滤推荐系统
-   基于模型的协同过滤推荐系统

要在机器学习领域有所成就，并不需要你弄懂这两类协同过滤推荐系统之间的差异，你只要知道协同过滤推荐系统存在不同种类就够了。

### 本节小结

以下是有关我们在这份导学中就推荐系统谈到的一些要点总结：

-   推荐系统在生活中的应用实例
-   推荐系统的不同类别以及协同过滤推荐系统比基于内容的推荐系统应用更为普遍的原因
-   推荐系统与线性代数之间的关系

# 线性回归

[线性回归][3]  的用途在于基于  `x`  值来预测  `y`  值。

### 线性回归的历史

19 世纪，线性回归由  [Francis Galton][4]提出。

Galton 是一名研究父母-子女关系的科学家。具体而言，他研究的是父亲身高同其儿子身高之间的关系。

Galton 的第一个发现是，儿子倾向于大致同父亲一样高，这并不足为奇。

但后来，获得一个更有趣的发现。那就是，一个儿子的身高  __倾向于更接近所有人身高的平均值，__ 比其同其父亲身高的接近度还要高__。__

Galton 为这一现象命名为：  ****回归****。 用他的话说，“一位父亲的儿子的身高倾向于回归到所有人身高的平均值”。

自此，统计学和机器学习迎来了一个崭新的领域，即回归。

### 线性回归的数学原理

创建回归模型时，我们要做的就是绘制一条尽可能接近数据集中每个点的线。

一个典型的例子是线性回归的“最小二乘法”，该方法仅计算上下方向上的一条线的相似度。

下面这个示例可以帮助阐释这一点：

![An example of the math behind least squares regression](https://nickmccullum.com/images/python-machine-learning/introduction-linear-regression/least-squares-regression.gif)

在创建回归模型时，你最终会产出一个方程式。利用它，你可以预测给定 x 值时的 y 值，而无需事先知道 y 值。

# 逻辑回归

[逻辑回归][5]  与线性回归类似。但不同的是，逻辑回归并不计算  `y`  的数值，而是估计一个数据点所属的  _类别_  。

### 什么是逻辑回归？

逻辑回归是一种用于解决分类问题的机器学习模型。

下面是几种机器学习分类问题的举例：

-   垃圾邮件（垃圾还是非垃圾？）
-   汽车保险索赔（销记还是维修？）
-   疾病诊断

以上每一个分类问题都有且仅有两类，被称为  **二进制分类**  问题。

逻辑回归非常适合用于解决  **二进制分类**  问题，我们只需要把不同类别的值分别设定为  `0`  和  `1`  就行了。

我们为什么需要逻辑回归？答案是，线性回归模型无法做出二进制分类推测，因为当用一个只包含两个可能值的数据集拟合一条直线时，拟合效果可想而知。

这张图片或能帮助你理解为什么线性回归模型不适用于解决二进制分类问题：

![Linear Regression Classification](https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/linear-regression-classification.png)

图中，  `y-axis`  代表一个肿瘤是恶性的可能性。相反，  `1-y`  代表其为良性的可能性。可以看到，就数据集中的大多数观测值而言，线性回归模型在预测这一可能性方面表现很差。

这也解释了逻辑回归的有用性。它拟合出的最佳曲线有一个偏向，这使它更适合预测分类数据。

下面是使用相同训练数据分别生成的线性回归模型与逻辑回归模型比较：

![Linear Regression vs Logistic Regression](https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/linear-vs-logistic-regression.png)

### S 型函数

逻辑回归模型生成的曲线之所以有一个偏向是因为它不是用线性方程计算得的，而是由 S 型函数（因其在逻辑回归中的应用又名逻辑函数）构建。

要在机器学习领域有所成就，你并不需要记忆  [S 型函数][6]  ，但是理解它的外形还是对你有帮助的。

其方程如下：

![The Sigmoid Equation](https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/sigmoid-equation.png)

有关 S 型函数值得知道的一点是，它有这样一个主要特征：无论你输入的值有多大，该函数输出的值始终分布在 0 到 1 之间。

### 利用逻辑回归模型开展预测

要利用线性回归模型进行预测，通常需要设定一个临界点，该临界点通常为  `0.5`。

我们不妨使用先前图片中的癌症诊断示例来在实践中理解这一原理。如果逻辑回归模型输出的值低于 0.5，该数据点将被归为良性肿瘤。反之，如果 S 型函数输出的值大于 0.5，则将被归为恶性。

### 使用混淆矩阵来衡量逻辑回归的性能

在机器学习领域，混淆矩阵可以用于比较真阳性，真阴性，假阳性和假阴性。

尤其是在衡量逻辑回归模型的性能时，混淆矩阵非常有用。下面是混淆矩阵的一个使用示例：

![An Example Confusion Matrix](https://nickmccullum.com/images/python-machine-learning/introduction-logistic-regression/confusion-matrix.png)

图中，TN 代表“真阴性”，FN 代表“假阴性”。FP 代表“假阳性”，TP 代表“真阳性”。

混淆矩阵可用于评估模型在混淆矩阵的某一特定象限中是否性能很差。举例来说，图中模型的假阳性异常偏高。

这种评估在某些应用场景中可以发挥很大的用处。它可以确保模型在混淆矩阵中极为危险的区域仍能表现良好。

拿癌症的例子来说，你会非常想要确定你的模型没有很高的假阴性率。因为真是那样的话，就意味着一个人明明患有恶性肿瘤，但你却将其错误地归为了良性。

### 本节小节

本节，你初次了解了逻辑回归机器学习模型。

以下是你就逻辑回归学到的知识总结：

-   哪些类型的分类问题适合利用逻辑回归模型解决
-   逻辑函数（也称为 S 型函数）的输出值永远在 0 到 1 之间
-   如何借助临界点来利用逻辑回归机器学习模型进行预测
-   为什么混淆矩阵可用于衡量逻辑回归模型的性能

# K 近邻算法

[K 近邻算法][7]  可以帮助解决类别多于两个的分类问题。

### 什么是 K 近邻算法？

K 近邻算法是一种分类算法。其基于的原理非常简单，通过一个示例我们便能对其进行很好的理解。

假设你有一些足球运动员和篮球运动员的身高、体重数据，那么当数据中出现了一个新运动员时，K 近邻算法便可帮你推测这名运动员是足球运动员还是篮球运动员。

为实现这一推测，K 近邻算法会识别最接近新观测值的  `K`  个数据点。

下图是这一过程的展示，其中 K 值为  `3`：

![A visualization of k nearest neighbors](https://nickmccullum.com/images/python-machine-learning/introduction-k-nearest-neighbors/k-nearest-neighbors.jpg)

图中，我们将足球运动员数据点标记为了蓝色，篮球运动员标记为了橙色，待归类的数据点标记为了绿色。

由于新数据点最邻近的数据点中大多数（2/3）是蓝色（足球运动员），因此 K 近邻算法预测这一新数据点也应为蓝色（足球运动员）。

### 建立 K 近邻算法的步骤

通常，建立一个 K 近邻算法有以下步骤：

1.  存储所有数据
2.  计算从新数据点  `x`  到数据集中其它所有数据点的  [欧式距离][8]
3.  按照距新数据点  `x`  的距离递增的顺序对数据集中的各数据点进行排序
4.  根据距新数据点  `x`  最近的  `K`  个数据点中绝大多数所属的类别推测新数据点的类别

### K 近邻算法中 K 值的重要性

尽管在一开始可能并不明显，但在 K 近邻算法中更改  `K`  值的大小或将改变对新数据点所属类别的推测结果。

具体而言，如果  `K`  值很小，那么一个模型便能完美地预测训练数据，但在预测测试数据时会表现较差。同样，  `K`  值太大则会导致模型过于复杂。

下图很好地说明了这一问题：

![K value and error rates](https://nickmccullum.com/images/python-machine-learning/introduction-k-nearest-neighbors/k-value-error-rates.png)

### K 近邻算法的优缺点

在 K 近邻算法介绍的最后，我想简要讨论一下使用该模型的利弊。

这是使用 K 近邻算法的一些主要优点：

-   该算法简单易懂
-   训练模型时没太大必要在新的训练数据上训练
-   适用于分类问题中的任何数量的类别
-   向数据集中添加更多数据时较为容易
-   该模型仅包含两个参数：  `K`  值和使用的距离指标（通常是欧式距离）

同时，以下是该算法的一些主要缺点：

-   由于需要对整个数据集进行排序，做出预测的计算成本高
-   不适用于分类功能

### 本节小节

以下是刚刚讲到的有关 k 近邻算法的知识总结：

-   K 近邻算法可以解决的分类问题示例（足球运动员与篮球运动员的例子）
-   K 近邻算法如何依据相邻数据点的欧几里得距离来预测新数据点属于哪个类别
-   为什么  `K`  值的大小对预测结果很重要
-   使用 K 近邻算法的优缺点

# 决策树和随机森林

[决策树和随机森林][9]  都归属于树方法。

具体来说，决策树也是一种机器学习模型，用于通过循环遍历数据集中的每个特征进行预测。随机森林则是按照数据集中的各个特征随机排布的决策树集合。

### 什么是树方法？

树方法是机器学习的一种方法。在深入探讨其理论依据之前，我们不妨先看一个示例。

假设你每个星期一都打篮球，而且你总是邀请同一个朋友和你一起打。

而你的这位朋友有些时候来了，有些时候没来。

他是否会来取决于多个因素，如天气好坏，气温高低，风的大小，身体疲惫程度。你渐渐注意到了这些因素，并开始记录你朋友是否会来的决定以及当天这些因素的具体情况。

如此一来，你便可以用这些数据来预测你的朋友在某个周一是否会来，而你预测时可选择的方法之一就是决策树。下图是本示例中的决策树：

![An example of a decision tree](https://nickmccullum.com/images/python-machine-learning/introduction-decision-tree/decision-tree.png)

每个决策树中都有两种构成元素：

-   `节点`：位于决策树根据某个属性的值分叉的位置
-   `方案枝`：拆分到下一个节点的结果

上图中，可以看到的一些节点有  `outlook（推测）`,  `humidity（湿度）`  and  `windy（风）`。这些属性的每种潜在值旁边都有一条树枝状的线条。

在继续深入探讨之前，你还需要了解下面两个决策树术语：

-   `根节点`：进行第一次拆分的节点
-   `叶节点`：预测最终结果的终端节点

现在，你对决策树已经有了一个基本的了解。在下一部分的讲解中，我们将学习如何从零开始构建决策树。

### 如何从零开始构建决策树

构建一个决策树比你想象的要难，因为要确定分割数据的特征（一个属于  [熵][10]  和  [信息增益][11]) 范畴的话题）在数学上是一个非常复杂的问题。

为了解决这个问题，机器学习从业人员通常会使用多个决策树，这些决策树分割特征的选取是从众多样本中随机挑选的。

换句话说，每个决策树在每个分割处都会随机选择一个新的特征样本，该方法被称为  **随机森林**。

总体而言，从业人员通常会将数据集中的特征总数  `p`  的平方根作为随机特征样本中包含的样本数量  `m`。简而言之，  `m`  等于  `p`  的平方根，每一个分割特征将从  `m`  中随机选择。

如果现在你无法完全理解也不必担心。当你最终构建第一个随机森林模型时，你便会对一切认识得更加清楚。

### 使用随机森林的优点

想象一下，假设你正在使用的数据集有一项非常显著的特征，这一特征比数据集中的其它任何特征都更能准确预测最终结果。

如果你用手工去构建决策树，便会将此特征画在决策树的顶部分叉，这也就意味着你将拥有多棵预测相关性很高的决策树。

然而，我们要避免这种情况的发生，因为取高度相关变量的平均值不能显著减小方差。相反，通过为随机森林中的每棵树随机选择特征，这些树之间便会失去相关性，从而减小结果模型的方差。这种去相关性是使用随机森林优于手工决策树的主要优势。

### 本节小节

以下是刚刚讲到的有关决策树和随机森林的知识总结：

-   可以使用决策树来进行预测的问题示例
-   决策树的构成元素：  `节点`，  `方案枝`，  `根节点`  和  `叶节点`
-   随机抽取决策树特征样本建立随机森林的原理
-   为什么使用随机森林对变量进行去相关有助于减小最终模型的方差

# 支持向量机

[支持向量机][12]  属于分类算法（尽管从技术上讲，它们也可以用于解决回归问题），它通过切分类别之间的最大差距，将数据集分为多个类别。稍后我们将以图示的方式对这一概念进行更加清晰的认识。

### 什么是支持向量机？

[支持向量机][13]  是一种监督机器学习模型，简称 SVMs（Support vector machines），该类模型具有用于分析数据和识别模式的关联学习算法。

支持向量机既可用于分类问题也可用于回归问题。本文将专门研究使用支持向量机解决分类问题。

### 支持向量机如何工作？

让我们一探究竟。

给定一组训练样本  – 标记每个样本属于两个类别中的一个  – 支持向量机训练算法建立模型。这样，输入新样本时，该模型便会将其归为两个类别之一。由此，支持向量机便成了一个非概率二进制线性分类器。

SVM 进行分类预测时所依据的是几何学。

具体而言，SVM 模型会将数据点映射为空间中的点并将每个单独的类别分隔开来，从而使划分的开放间隙尽可能宽。根据新数据点属于间隙的哪一侧，SVM 将预测它们属于哪个类别。

下图是一个可视化示例，可以帮你更好理解支持向量机背后的机理：

![](https://www.freecodecamp.org/news/content/images/2020/06/image-57.png)

如图所示，如果新数据点位于绿线的左侧，则 SVM 会将其标记为红色类别。反之，如果新数据点位于绿线的右侧，SVM 则会将其标记为蓝色类别。

而这条绿线被称为  **超平面**，这是支持向量机算法相关的一个重要术语。

让我们看一下支持向量机的另一种视觉表示形式：

![](https://www.freecodecamp.org/news/content/images/2020/06/image-58.png)

这幅图中的超平面被标记为了  **最佳超平面**。支持向量机理论将  **最佳超平面**  定义为能够最大化每个类别之间最接近的几个数据点之间间距的超平面。

如图所示，示例中的边距线共接触到三个数据点，其中两个来自红色类别，一个来自蓝色类别。这些触及边距线的数据点被称为  **支持向量**  ，支持向量机也因其得名。

### 本节小节

以下是刚刚讲到的有关支持向量机的知识总结：

-   支持向量机是一种监督机器学习算法
-   支持向量机可用于解决分类和回归问题
-   支持向量机是如何利用（可最大化数据集中类别之间间距的）  **超平面**  对数据点进行分类的
-   支持向量机中，接触边距线的数据点被称为  **支持向量**，支持向量机也因其得名。

# K 均值聚类

[K 均值聚类][14]  是一种可用于识别数据集内类似数据片段的机器学习算法。

### 什么是 K 均值聚类？

K 均值聚类是一种无监督机器学习算法。

意思是说，接收未标记的数据后它会尝试将数据中类似的观测组归在一起。

K 均值聚类算法在解决现实问题时非常有用。下面是该机器学习模型的几个应用举例：

-   帮助营销团队对客户进行细分
-   文件分类
-   帮助亚马逊、UPS、联邦快递等公司最优化快递运输路线
-   识别、应对城市犯罪中心
-   专业运动分析
-   预防网络犯罪

K 均值聚类算法的主要功能是将数据集划分为不同的组，使每组内的观测结果彼此相似。

下图是其实际运作的可视化呈现：

![A Visualization of a K Means Clustering Algorithm](https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/k-means-clustering.png)

我们将在下一节探索 K 均值聚类背后的数学原理。

### K 均值聚类算法如何运作？

运行 K 均值聚类算法的第一步是选择要将数据划分为多少个集群。这一集群数便是该算法名称中的  `K`  值。

使用 K 均值聚类算法时，  `K`  值的选择非常关键。稍后我们会讨论如何选择合适的  `K`  值。

下一步，必须随机将数据集中的每个数据点都分配到随机聚类中，这也是第一步任务的根源所在。然后运行以下迭代，直到集群停止更改：

-   通过计算该集群内数据点的平均向量来计算每个集群的几何中心
-   将每个数据点重新分配到同其先前所在集群几何中心最接近的集群

下面的动画是这一实践过程的示例。其中，K 均值聚类算法的  `K`  值为  `3`。可以看到，每个集群的几何中心均由黑色的  `+`  字符表示。

![A Visualization of a K Means Clustering Algorithm](https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/k-means-iteration.gif)

如图所示，此迭代将一直持续到集群停止更改为止，这一停止更改意味着数据点将不会再被分配到新的集群。

### 为 K 均值聚类算法选择合适的 K 值

要为 K 均值聚类算法选择一个合适的  `K`  值实际上相当困难。该值的“最佳”选择没有“标准”答案。

机器学习从业者经常使用的一种方法叫做  **肘部法**。

使用肘部法时，第一步要先计算一组  `K`  值下 K 均值聚类算法的误差平方和（SSE，sum of squared errors）。SSE 表示一个集群中的每个数据点与该集群几何中心之间的距离的平方之和。

举例来说，计算 SSE 时，你可以选择  `K`  值为  `2`，  `4`，  `6`，  `8`，  `10`。

接着，将不同  `K`  值下的 SSE 绘制在图表中。可以看到，随着  `K`  值的增大，错误逐渐减少。

这也是符合常理的——数据集中创建的类别越多，每个数据点接近其特定集群几何中心的可能性就越大。

说了这么多，肘部法的用意就在于选择 SSE 下跌速度突然放缓处的  `K`  值，这种突然的放缓在图表中往往会生成了一个  `肘`  形。

下图是一个 SSE 和  `K`  的关系图表示例。图中，肘部法建议的  `K`  值大约为  `6`。

![A Visualization of a K Means Clustering Algorithm](https://nickmccullum.com/images/python-machine-learning/introduction-k-means-clustering/elbow-method.png)

值得注意的是，  `6`  只是对最佳  `K`  值的一种估计。 K 均值聚类算法中并没有标准的“最佳”  `K`  值。同机器学习领域的许多事物一样，这一最佳选择高度依赖具体情况。

### 本节小节

以下是本节内容的小结：

-   K 均值聚类算法能够解决的无监督机器学习问题示例
-   K 均值聚类算法的基础机理
-   K 均值聚类算法的工作原理
-   如何利用肘方法为 K 均值聚类模型选择合适的  `K`  值

# 主要组件分析

[主要组件分析][15]  用于将多特征数据集转换为具有较少特征的转换数据集，转换数据集中的每个新特征是预先数据集存在特征的线性组合。此转换数据集旨在更简单地解释原始数据集中的绝大部分变量。

### 什么是主要组件分析

主要组件分析是一种用于检查变量集间相互关系的机器学习方法。

不同的是，主要组件分析研究一组变量，以确定这些变量的根本结构。

主要组件分析有时也被称为  ****因子分析****。

基于此描述，你可能会感觉主要组件分析与线性回归非常相似。

但事实并非如此。其实，二者存在一些显著区别。

### 线性回归与主要组件分析的区别

线性回归通过数据集确定一条最佳拟合线，而主要组件分析会确定出几条最拟合数据集的正交线。

**正交**的意思可以理解为线与线之间呈直角（90 度）相交——就像地图上指示北、东、南、西的方向坐标那样。

我们不妨通过下面的示例来帮助你更好的理解。

![A principal component analysis](https://nickmccullum.com/images/python-machine-learning/introduction-principal-component-analysis/principal-component-analysis.png)

仔细看图中的轴标。

图中，x 轴的主要组件代表了该数据集中 73%的变量，y 轴的主要组件则解释了数据集中 23%的变量。

这就意味着数据集中仍有 4%的变量未得到解释。通过在分析中添加更多主要组件，这一未解释变量的数量便能减至更少。

### 本节小节

以下是刚刚讲到的有关主要组件分析的知识总结：

-   主要组件分析致力于找到确定数据集变异性的正交因子
-   主要组件分析与线性回归之间的区别
-   正交主要组件在数据集内的可视化图示
-   添加更多主要组件可以帮助解释数据集中的更多变量

  

[1]: https://gum.co/pGjwd
[2]: https://nickmccullum.com/python-machine-learning/introduction-recommendation-systems/
[3]: https://nickmccullum.com/python-machine-learning/linear-regression-python/
[4]: https://en.wikipedia.org/wiki/Francis_Galton
[5]: https://nickmccullum.com/python-machine-learning/logistic-regression-python/
[6]: https://en.wikipedia.org/wiki/Sigmoid_function
[7]: https://nickmccullum.com/python-machine-learning/k-nearest-neighbors-python/
[8]: https://en.wikipedia.org/wiki/Euclidean_distance
[9]: https://nickmccullum.com/python-machine-learning/decision-trees-random-forests-python/
[10]: https://en.wikipedia.org/wiki/Entropy
[11]: https://machinelearningmastery.com/information-gain-and-mutual-information/#:~:text=Information%20gain%20is%20the%20reduction,before%20and%20after%20a%20transformation.
[12]: https://nickmccullum.com/python-machine-learning/support-vector-machines-python/
[13]: https://en.wikipedia.org/wiki/Support_vector_machine
[14]: https://nickmccullum.com/python-machine-learning/k-means-clustering-python/
[15]: https://nickmccullum.com/python-machine-learning/principal-component-analysis-python/
