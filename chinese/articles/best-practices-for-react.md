> -  ÂéüÊñáÂú∞ÂùÄÔºö[React Best Practices ‚Äì Tips for Writing Better React Code in 2022](https://www.freecodecamp.org/news/best-practices-for-react/)
> -  ÂéüÊñá‰ΩúËÄÖÔºö[Jean-Marc M√∂ckel](https://www.freecodecamp.org/news/author/jeanmarcmoeckel/)
> -  ËØëËÄÖÔºöluojiyin
> -  Ê†°ÂØπËÄÖÔºö

![React Best Practices ‚Äì Tips for Writing Better React Code in 2022](https://www.freecodecamp.org/news/content/images/size/w2000/2022/02/React-Best-Practices-Thumbnail.png)

‰∏§Âπ¥ÂâçÔºåÊàëÂºÄÂßãÂ≠¶‰π†Âíå‰ΩøÁî®React„ÄÇ‰ªäÂ§©ÔºåÊàë‰ªçÁÑ∂Âú®ÊàëÁöÑÊó•Â∏∏Â∑•‰Ωú‰∏≠‰ΩøÁî®ÂÆÉÔºå‰Ωú‰∏∫‰∏Ä‰∏™ËΩØ‰ª∂ÂºÄÂèë‰∫∫ÂëòÂíåÊàëËá™Â∑±ÁöÑ‰∏ö‰ΩôÈ°πÁõÆ„ÄÇ

Âú®ËøôÊÆµÊó∂Èó¥ÈáåÔºåÊàëÈÅáÂà∞‰∫ÜÂæàÂ§öÂÖ∏ÂûãÁöÑÈóÆÈ¢ò„ÄÇÊâÄ‰ª•ÊàëÂõõÂ§ÑÊêúÂØªÔºåÊâæÂà∞‰∫Ü‰∏Ä‰∫õÊúÄ‰Ω≥ÂÆûË∑µÔºåÂπ∂Â∞ÜÂÖ∂Êï¥ÂêàÂà∞ÊàëÁöÑÂ∑•‰ΩúÊµÅÁ®ã‰∏≠ÔºåÊàëÊÉ≥Âá∫‰∫Ü‰∏Ä‰∫õËÆ©ÊàëÁöÑÁîüÊ¥ªÊàñÊàëÁöÑÂõ¢ÈòüÊàêÂëòÁöÑÁîüÊ¥ªÊõ¥ËΩªÊùæÁöÑ‰∏úË•ø„ÄÇ

‰∏ÄË∑ØËµ∞Êù•ÔºåÊàë‰πüÈÅáÂà∞‰∫Ü‰∏Ä‰∫õÊåëÊàòÔºåÂΩìÊó∂ÊàëÊ≤°Êúâ‰ª•ÊúÄÂ•ΩÁöÑÊñπÂºèÊù•Ëß£ÂÜ≥ÔºåÊàëÂ∏åÊúõÂ∞ÜÊù•ËÉΩ‰ª•Êõ¥Â•ΩÁöÑÊñπÂºèÊù•Â§ÑÁêÜËøô‰∫õÈóÆÈ¢ò„ÄÇ

ËøôÂ∞±ÊòØÊàëÂÜôËøô‰∏™ÊåáÂçóÁöÑÂéüÂõ†„ÄÇÊàëËÆ§‰∏∫ÂÆÉÂ∞±ÂÉè‰∏§Âπ¥ÂâçÊàëÂºÄÂßãÂ∑•‰ΩúÊó∂ÁªôËá™Â∑±ÁöÑÊäÄÂ∑ßÊî∂ÈõÜ„ÄÇ

## ÁõÆÂΩï:

-   [ReactÂºÄÂèëËÄÖÈù¢‰∏¥ÁöÑ‰∏âÂ§ßÊåëÊàò](#three-major-challenges-react-developers-face)
-   [Â≠¶‰π†ReactÁöÑÊûÑÂª∫Ê®°Âùó](#learn-the-building-blocks-of-react)
-   [Â≠¶‰π†Â¶Ç‰ΩïÊûÑÂª∫ÁÆÄÊ¥Å„ÄÅÊÄßËÉΩËâØÂ•Ω„ÄÅÂèØÁª¥Êä§ÁöÑReactÁªÑ‰ª∂](#learn-how-to-build-clean-performant-and-maintainable-react-components)
-   [Â∏ÆÂä©‰Ω†ÂÜôÂá∫Êõ¥Â•ΩÁöÑReact‰ª£Á†ÅÁöÑÊäÄÂ∑ß ‚Äì The Cherries on Top](#tips-to-help-you-write-better-react-code-the-cherries-on-top)
-   [ÁªìÊùüËØ≠](#final-words)

È¶ñÂÖàÔºå‰Ω†‰ºö‰∫ÜËß£Âà∞ÊØè‰∏™ReactÂºÄÂèëËÄÖÂøÖÈ°ªÈù¢ÂØπÁöÑ **‰∏â‰∏™‰∏ªË¶ÅÊåëÊàò** ÔºåËøôÂæàÈáçË¶ÅÔºåÂõ†‰∏∫ÂΩì‰Ω†ÊÑèËØÜÂà∞ÊΩúÂú®ÁöÑÊåëÊàòÊó∂Ôºå‰Ω†‰ºöÊõ¥Ê∑±ÂÖ•Âú∞ÁêÜËß£Ëøô‰∫õÊúÄ‰Ω≥ÂÆûË∑µËÉåÂêéÁöÑÂéüÂõ†„ÄÇ‰ªé‰∏ÄÂºÄÂßãÂ∞±ÊúâËøôÁßçÂøÉÊÄÅÔºå‰πüÊúâÂä©‰∫é‰Ω†Âú®ËÆæËÆ°‰Ω†ÁöÑÁªÑ‰ª∂ÊàñÁªÑÁªá‰Ω†ÁöÑÈ°πÁõÆ„ÄÇ

Âú®ËøôÁ¨¨‰∏Ä‰∏™ÈáçË¶ÅÊ≠•È™§‰πãÂêéÔºåÊàëÂ∞ÜÂêë‰Ω†‰ªãÁªç**ÁöÑ‰∏â‰∏™ÊúÄ‰Ω≥ÂÆûË∑µ**„ÄÇÂÆÉ‰ª¨ÊòØÁêÜËÆ∫ÂíåÂÆûË∑µÊäÄÂ∑ßÁöÑÊ∑∑Âêà‰ΩìÔºåÂ∏¶Êúâ‰ª£Á†ÅÂÆû‰æã„ÄÇÊàëÂ∞ΩÈáèÂáèÂ∞ë _hello world_ ÁöÑÈóÆÈ¢òÔºåÂπ∂ÊãøÂá∫ÊàëÂú® _ÁúüÂÆû‰∏ñÁïå_ ÁúãÂà∞ÁöÑ‰ª£Á†Å„ÄÇ

## Three Major Challenges React Developers Face

![christian-erfurt-sxQz2VfoFBE-unsplash](https://www.freecodecamp.org/news/content/images/2022/01/christian-erfurt-sxQz2VfoFBE-unsplash.jpg)

Âú®ÊàëÊó•Â∏∏‰ΩøÁî®ReactÁöÑ‰∏§Âπ¥Êó∂Èó¥ÈáåÔºåÊàëËÆ§ËØÜÂà∞ReactÂºÄÂèëËÄÖÂú®ÊûÑÂª∫‰ªñ‰ª¨ÁöÑÂ∫îÁî®Êó∂Èù¢‰∏¥ÁöÑ‰∏âÂ§ßÊåëÊàò„ÄÇÂøΩËßÜËøô‰∫õÊåëÊàòÂèØËÉΩ‰ºöÂ∏¶Êù•Âõ∞ÈöæÔºåÊçüÂÆ≥‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫èÁöÑÂèëÂ±ï„ÄÇ

Âõ†Ê≠§ÔºåÂú®ÂçèË∞É‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫èÊó∂Ë¶ÅËÆ∞‰ΩèËøô‰∫õÊåëÊàò,ËøôÂ∞ÜËäÇÁúÅ‰Ω†ÁöÑÊó∂Èó¥ÂíåÁ≤æÂäõ„ÄÇ

### ‚öôÔ∏è ÂèØÁª¥Êä§ÊÄß

Ëøô‰∏é _ÂèØÈáçÁî®ÊÄß_ ÊòØÁõ∏ËæÖÁõ∏ÊàêÁöÑ„ÄÇ‰∏ÄÂºÄÂßãÔºåÂΩìÂ∫îÁî®Á®ãÂ∫èÂíåÁªÑ‰ª∂ÈùûÂ∏∏ËΩªÂ∑ßÊó∂ÔºåÂÆÉ‰ª¨ÂæàÂÆπÊòìÁª¥Êä§„ÄÇ‰ΩÜÊòØÔºå‰∏ÄÊó¶ÈúÄÊ±ÇÂºÄÂßãÂ¢ûÈïøÔºåÁªÑ‰ª∂Â∞±‰ºöÂèòÂæóÈùûÂ∏∏Â§çÊùÇÔºåÂõ†Ê≠§ÂèØÁª¥Êä§ÊÄßÂ∞±‰ºöÈôç‰Ωé„ÄÇ

ÊàëÁªèÂ∏∏ÁúãÂà∞‰∏Ä‰∏™ÁªÑ‰ª∂ÊúâÂæàÂ§ö‰∏çÂêåÁöÑÊÉÖÂÜµÔºåÊØè‰∏™ÈÉΩ‰ª£Ë°®‰∏çÂêåÁöÑÁªìÊûú„ÄÇJSX‰∏≠ÂÖÖÊñ•ÁùÄÊù°‰ª∂Ê∏≤ÊüìÔºà‰∏âÂÖÉËøêÁÆóÁ¨¶ÂíåÁÆÄÂçïÁöÑ`&&`ËøêÁÆóÁ¨¶ÔºâÔºå`classnames`Ë¢´ÊúâÊù°‰ª∂Âú∞Â∫îÁî®ÔºåÊàñËÄÖÁªÑ‰ª∂‰ΩøÁî®Â∑®Â§ßÁöÑ`switch`ËØ≠Âè•„ÄÇÊúâËÆ∏Â§öÂèØËÉΩÁöÑ`props`Âíå`state`ÂÄºÔºåÊØè‰∏™ÈÉΩË¥üË¥£‰∏çÂêåÁöÑÁªìÊûú„ÄÇ

Âú®ÊàëÁúãÊù•ÔºåËøô‰∫õÊäÄÊúØÊú¨Ë∫´Âπ∂Ê≤°ÊúâÈîô„ÄÇ‰ΩÜÊàëËÆ§‰∏∫ÊØè‰∏™‰∫∫ÈÉΩÂ∫îËØ•ÂüπÂÖª‰∏ÄÁßçÊÑüËßâÔºåÁü•ÈÅì‰ªÄ‰πàÊó∂ÂÄô‰∏Ä‰∏™ÁªÑ‰ª∂ÂºÄÂßãÂèòÂæó‰∏çÈÇ£‰πàÂèØÁª¥Êä§Ôºå‰ªÄ‰πàÊó∂ÂÄôËøô‰∫õÊäÄÊúØË¢´ËøáÂ∫¶‰ΩøÁî®„ÄÇÊàë‰ª¨Â∞ÜÂú®ÊñáÁ´†ÁöÑÂêéÈù¢Â≠¶‰π†Â¶Ç‰ΩïÊõ¥Â•ΩÂú∞ÊéßÂà∂Ëøô‰∏™ÈóÆÈ¢ò„ÄÇ

ÈóÆÈ¢òÊòØÔºàÊàë‰πüÊõæÁäØËøáËøôÊ†∑ÁöÑÈîôËØØÔºâÔºå‰∏Ä‰∏™ÁªÑ‰ª∂ÁöÑÂ§çÊùÇÊÄßÂíå‰∏çÂêåÁªìÊûúË∂äÂ§öÔºàpolymorphismÔºâÔºåÂÆÉÂ∞±Ë∂äÈöæÁª¥Êä§„ÄÇ

ËØ¥ÂÆûËØùÔºåÂÖ∂Ê†πÊú¨ÂéüÂõ†ÂæÄÂæÄÊòØÊáíÊÉ∞ÔºåÊ≤°ÊúâË∂≥Â§üÁöÑÁªèÈ™åÔºåÊàñÊó∂Èó¥ÂéãÂäõÔºåÊó†Ê≥ïÊ≠£Á°ÆÂú∞ÈáçÊûÑ‰∏Ä‰∏™ÁªÑ‰ª∂Ôºå‰ª•‰ΩøÂÖ∂Êõ¥ÂèØÁª¥Êä§ÂíåÊõ¥ÁÆÄÊ¥Å„ÄÇ

ÊàëÁúãÂà∞ÁöÑÂè¶‰∏Ä‰∏™ÂÖ≥ÈîÆÂõ†Á¥†ÊòØÊ≤°ÊúâÊàñÂæàÂ∞ëËøõË°åÊµãËØï„ÄÇÊàëÁü•ÈÅìÔºåÊµãËØïÂπ∂‰∏çÊòØÂæàÂ§öÂºÄÂèë‰∫∫ÂëòÂñúÊ¨¢ÁöÑÂ∑•‰ΩúÔºå‰ΩÜ‰ªéÈïøËøúÊù•ÁúãÔºåÂÆÉÁ°ÆÂÆûÂèØ‰ª•Â∏ÆÂä©‰Ω†„ÄÇÊµãËØïÊú¨Ë∫´‰∏ç‰ºöÊòØËøôÁØáÊñáÁ´†ÁöÑ‰∏Ä‰∏™‰∏ªË¶ÅËØùÈ¢òÔºåÊâÄ‰ª•ËØ∑ÁïôÊÑèÊàëÁöÑÂè¶‰∏ÄÁØáÂÖ≥‰∫éÊµãËØïÁöÑÂçöÊñá„ÄÇ

### üß† ÂØπReactÁöÑÊ∑±ÂàªÁêÜËß£

ReactÂºÄÂèëËÄÖÂá∫Áé∞ÈóÆÈ¢òÁöÑÂè¶‰∏Ä‰∏™Ê†πÊú¨ÂéüÂõ†ÊòØÂØπReactÂú®Â∑•‰ΩúÂ∫ïÂ±ÇÂéüÁêÜÁº∫‰πèÂü∫Êú¨‰∫ÜËß£„ÄÇÊàë‰πüÈÅáÂà∞ËøáËøôÁßçÊÉÖÂÜµ„ÄÇ

ÊàëËßÅËøáÂæàÂ§ö‰∫∫Âú®Ê≤°ÊúâÂùöÂÆûÂü∫Á°ÄÁöÑÊÉÖÂÜµ‰∏ãËøáÂø´Âú∞ËøõÂÖ•‰∏≠Á∫ßÊàñÈ´òÁ∫ßÊ¶ÇÂøµ„ÄÇ‰ΩÜËøôÂπ∂‰∏ç‰ªÖ‰ªÖÊòØReactÁöÑÈóÆÈ¢ò„ÄÇËøô‰πüÊòØÁºñÁ®ã‰∏≠ÁöÑ‰∏Ä‰∏™ÊôÆÈÅçÈóÆÈ¢ò„ÄÇ

ÂØπReactÊ≤°ÊúâÊâéÂÆûÁöÑ‰∫ÜËß£‰πü‰ºöÁªô‰Ω†Ëøô‰∏™ÂºÄÂèëËÄÖÂ∏¶Êù•ÈóÆÈ¢ò„ÄÇÊàëËÆ∞ÂæóÂΩìÊàëÊÉ≥‰ΩøÁî®‰∏çÂêåÁöÑÁªÑ‰ª∂ÁîüÂëΩÂë®ÊúüÔºå‰ΩÜ‰∏çÁü•ÈÅìÂ¶Ç‰ΩïÁúüÊ≠£‰ΩøÁî®ÂÆÉ‰ª¨Êó∂ÔºåÊàëÂæàÂ§¥Áñº„ÄÇÊâÄ‰ª•Êàë‰∏çÂæó‰∏çÈÄÄÂõûÂéªÔºåÊ∑±ÂÖ•‰∫ÜËß£Ëøô‰∏™ËØùÈ¢ò„ÄÇ

Âõ†‰∏∫ÊàëËÆ§‰∏∫ËøôÊòØÊúÄÈáçË¶ÅÁöÑ‰∫ãÊÉÖ‰πã‰∏ÄÔºåÊâÄ‰ª•ÊàëÂú®‰∏ãÈù¢ËøôÁØáÂçöÊñá‰∏≠‰∏ìÈó®Áî®‰∫Ü‰∏ÄÊï¥Á´†Êù•‰ªãÁªç„ÄÇ

### üìà ÂèØÊâ©Â±ïÊÄß

Ëøô‰∏™ÊåëÊàò‰∏é _ÂèØÁª¥Êä§ÊÄß_ Âπ∂È©æÈΩêÈ©±„ÄÇÂÆÉ‰∏ç‰ªÖÊòØReactÊâÄÁâπÊúâÁöÑÔºåËÄå‰∏îÊôÆÈÅçÈÄÇÁî®‰∫éËΩØ‰ª∂‰∏≠„ÄÇ

ÊàëÂ∑≤Áªè‰∫ÜËß£Âà∞ÔºåÂà∂‰Ωú‰ºòÁßÄÁöÑËΩØ‰ª∂‰∏ç‰ªÖ‰ªÖÊòØÁî®Êà∑‰ΩìÈ™å„ÄÅÂπ≤ÂáÄÁöÑ‰ª£Á†ÅÊ®°ÂºèÊàñËÅ™ÊòéÁöÑÊû∂ÊûÑÔºå‰æãÂ¶Ç„ÄÇÂØπÊàëÊù•ËØ¥Ôºå‰∏Ä‰∏™ËΩØ‰ª∂ÁöÑË¥®Èáè‰πüÈöèÁùÄÂÆÉÁöÑÊâ©Â±ïËÉΩÂäõËÄå‰∏äÂçáÊàñ‰∏ãÈôç„ÄÇ

ÂØπÊàëÊù•ËØ¥ÔºåÂæàÂ§ö‰∏úË•øÈÉΩËÉΩÊèêÈ´òËΩØ‰ª∂ÁöÑÂèØÊâ©Â±ïÊÄß„ÄÇÂú®ËøôÁØáÊñáÁ´†‰∏≠Ôºå‰Ω†‰ºöÂ≠¶Âà∞ÊàëÊúÄÈáçË¶ÅÁöÑÊäÄÂ∑ß„ÄÇ

ÊàëËÆ§‰∏∫ÔºåÂΩì‰Ω†Âú®Ë∞ÉÊï¥‰Ω†ÁöÑÁªÑ‰ª∂ÂíåÁªÑÁªá‰Ω†ÁöÑÈ°πÁõÆÁªìÊûÑÊó∂ÔºåÊää _ÂèØÁª¥Êä§ÊÄß_ Âíå _ÂèØÊâ©Â±ïÊÄß_ ÊîæÂú®ÂøÉ‰∏äÔºå‰Ω†Â∞±‰∏çÂ§™ÂèØËÉΩ‰ª•ÈúÄË¶ÅÈáçÂ§ßÈáçÊûÑÁöÑÊ∑∑‰π±ÁöÑÊ∫ê‰ª£Á†Å„ÄÇ

# Â¶Ç‰ΩïÂ≠¶‰π†React

Â•Ω‰∫ÜÔºåÁé∞Âú®ËÆ©Êàë‰ª¨Ê∑±ÂÖ•‰∫ÜËß£Â≠¶‰π†ReactÁöÑ‰∏Ä‰∫õÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇ

## Learn the Building Blocks of React

![brett-jordan-Lzfxzip-pNI-unsplash](https://www.freecodecamp.org/news/content/images/2022/01/brett-jordan-Lzfxzip-pNI-unsplash.jpg)

Ê≠£Â¶ÇÊàë‰ª¨Âú®‰∏äÈù¢ÁÆÄÂçïËÆ®ËÆ∫ÁöÑÈÇ£Ê†∑Ôºåbuilding blocks‰∏ç‰ªÖ‰∏éÂ≠¶‰π†ReactÊúâÂÖ≥ÔºåËÄå‰∏î‰∏éÂÖ∂‰ªñÊäÄÊúØÊàñÁºñÁ®ãËØ≠Ë®Ä‰πüÊúâÂÖ≥„ÄÇ‰Ω†‰∏çËÉΩÂú®ÊµÆÊ≤ô‰∏äÂª∫ÈÄ†‰∏ÄÂ∫ßÊë©Â§©Â§ßÊ•ºÔºåÂπ∂ÊúüÊúõÂÆÉÊòØÁâ¢Âõ∫ÁöÑ„ÄÇ

ËøôÂØπ‰Ω†‰ª¨‰∏≠ÁöÑËÆ∏Â§ö‰∫∫Êù•ËØ¥ÂèØËÉΩÊòØÊòæËÄåÊòìËßÅÁöÑÔºå‰ΩÜÊàëËßÅËøá‰∏Ä‰∫õÂºÄÂèëËÄÖÂú®Ê≤°ÊúâÁúüÊ≠£ÁêÜËß£Âü∫Á°ÄÁü•ËØÜÁöÑÊÉÖÂÜµ‰∏ãÂ∞±Ë∑≥ËøõReactÁöÑ‰∏≠Á∫ßÊàñÈ´òÁ∫ßÊ¶ÇÂøµ„ÄÇ

ËøôÂØπ‰∏ÄËà¨ÁöÑJavascriptÊù•ËØ¥‰πüÊòØÂ¶ÇÊ≠§„ÄÇÊàëÈùûÂ∏∏Áõ∏‰ø°ÔºåÂ¶ÇÊûú‰Ω†Ê≤°ÊúâÂùöÂÆûÁöÑVanilla JavascriptÂü∫Á°ÄÔºåÂ≠¶‰π†ReactÊòØÊ≤°ÊúâÊÑè‰πâÁöÑ„ÄÇ

ÊâÄ‰ª•ÔºåÂ¶ÇÊûúËøôÂê¨Ëµ∑Êù•ÂæàÁÜüÊÇâÔºåËÄå‰∏î‰Ω†Ê≠£Âú®ËÄÉËôëÂ≠¶‰π†ReactÔºå‰ΩÜÂØπVanilla JavascriptÂ∑≤ÁªèÊÑüËßâ‰∏çÊòØÂæàËàíÊúçÔºåÈÇ£Â∞±ÂÖàÂ§öËä±‰∫õÊó∂Èó¥Âä†Âº∫Javascript„ÄÇËøôÂ∞Ü‰∏∫‰Ω†Âú®Êú™Êù•ËäÇÁúÅÂ§ßÈáèÁöÑÂ§¥ÁóõÂíåÊó∂Èó¥„ÄÇ

Â¶ÇÊûú‰Ω†ÊÉ≥ÂõûÈ°æ‰∏Ä‰∏ãÔºåËøôÈáåÊúâ‰∏Ä‰ªΩÂÖ≥‰∫é[Â≠¶‰π†React‰πãÂâç‰Ω†ÈúÄË¶ÅÁü•ÈÅìÁöÑÊ†∏ÂøÉJavaScriptÊ¶ÇÂøµ](https://www.freecodecamp.org/news/top-javascript-concepts-to-know-before-learning-react/) 

‰ΩÜ‰ªÖ‰ªÖ‰∫ÜËß£Âü∫Á°ÄÁü•ËØÜÂØπÊàëÊù•ËØ¥ÊòØ‰∏çÂ§üÁöÑ„ÄÇÁü•ÈÅìReactÁöÑÂ∫ïÂ±ÇÊòØÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑÔºåËøôÊúâÁÇπÂº∫Âà∂ÊÄß„ÄÇÂ¶ÇÊûú‰Ω†ÊÉ≥Êàê‰∏∫‰∏Ä‰∏™‰ºòÁßÄÁöÑReactÂºÄÂèëËÄÖÔºàÊàëÊÉ≥‰Ω†ÊòØËøôÊ†∑ÊÉ≥ÁöÑÔºåÂõ†‰∏∫‰Ω†Ê≠£Âú®ÈòÖËØªËøôÁØáÊñáÁ´†ÔºâÔºå‰Ω†ÂøÖÈ°ª‰∫ÜËß£‰Ω†ÊâÄ‰ΩøÁî®ÁöÑÂ∑•ÂÖ∑„ÄÇËøôÂØπ‰Ωú‰∏∫ÂºÄÂèëËÄÖÁöÑ‰Ω†Âíå‰Ω†ÁöÑÂÆ¢Êà∑Êù•ËØ¥ÈÉΩÊòØÊúâÁõäÁöÑ„ÄÇ

‰∏ÄÊñπÈù¢ÔºåÂÆÉÂèØ‰ª•‰∏∫‰Ω†ËäÇÁúÅÂ§ßÈáèÁöÑÊó∂Èó¥Êù•Ë∞ÉËØï‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫è„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåÂÆÉ‰Ωø‰Ω†Êõ¥ÊúâÊïàÁéáÔºåÂõ†‰∏∫‰Ω†‰∏çÂøÖ‰∏ÄÊ¨°Âèà‰∏ÄÊ¨°Âú∞Êù•ÈáçÊñ∞Â≠¶‰π†Âü∫Êú¨Áü•ËØÜ„ÄÇ‰Ω†Âü∫Êú¨‰∏äÁü•ÈÅì‰Ω†Âú®ËØ¥‰ªÄ‰πà„ÄÇ

ÂΩìÁÑ∂Ôºå‰Ω†‰∏çÂèØËÉΩÁü•ÈÅìÊâÄÊúâÁöÑ‰∏úË•øÔºå‰Ω†‰∏çÂ∫îËØ•Âú®Ëøô‰∏™ËØùÈ¢ò‰∏äÁªôËá™Â∑±ÂéãÂäõ„ÄÇÂΩì‰Ω†ÈÄöËøáÂÆûÈôÖÈóÆÈ¢òÂíåÂª∫Á´ãÊõ¥Â§öÈ°πÁõÆÊó∂Ôºå‰Ω†‰ºöÂ≠¶Âà∞Ë∂äÊù•Ë∂äÂ§öÁöÑ‰∏úË•ø„ÄÇ‰ΩÜÊòØÔºåÊúâ‰∫ÜËâØÂ•ΩÊâéÂÆûÁöÑÁü•ËØÜÔºå‰Ω†ÂèØ‰ª•‰∫ãÂçäÂäüÂÄç„ÄÇ

Â•ΩÁöÑÔºåËøôÂæàÊúâÊÑè‰πâ„ÄÇ‰ΩÜ‰Ω†ÂèØËÉΩÊÉ≥Áü•ÈÅìÔºå‰∏∫‰∫ÜÂú®ReactÊñπÈù¢Êúâ‰∏Ä‰∏™ÂùöÂÆûÁöÑÂü∫Á°ÄÔºå‰Ω†Âà∞Â∫ïÈúÄË¶ÅÁü•ÈÅì‰ªÄ‰πàÔºü

‰Ωú‰∏∫‰∏Ä‰∏™ÊúÄ‰ΩéË¶ÅÊ±ÇÔºå‰Ω†Â∫îËØ•‰∫ÜËß£ÊâÄÊúâÁöÑ‰∏ªÈ¢ò„ÄÇ Âú®ÂÆòÊñπÁöÑReact DocsÈáåÈù¢ÁöÑ[**‰∏ªË¶ÅÊ¶ÇÂøµ** Á´†ËäÇ](https://reactjs.org/docs/hello-world.html)„ÄÇ

Âè¶‰∏Ä‰∏™ [‰Ω†Â∫îËØ•ÈùûÂ∏∏ÁÜüÊÇâÁöÑÁ´†ËäÇÊòØÂÖ≥‰∫é **Hooks**](https://reactjs.org/docs/hooks-intro.html)ÔºåÂõ†‰∏∫ÂÆÉ‰ª¨Â∑≤ÁªèÊàê‰∏∫‰∏ÄÁßçÊÉØ‰æãÔºåÂπ∂‰∏îÂà∞Â§ÑÈÉΩÂú®‰ΩøÁî®ÔºåÁâπÂà´ÊòØÂú®Á¨¨‰∏âÊñπReactÂåÖ‰∏≠„ÄÇ

ÂΩìÁÑ∂ÔºåÊúâ‰∏Ä‰∫õ‰Ω†ÂèØËÉΩÊõ¥ÁªèÂ∏∏‰ΩøÁî®ÔºåÂ¶Ç`useState`Âíå`useEffect`Ôºå‰ΩÜ‰∫ÜËß£ÂÖ∂‰ªñÁöÑÂ¶Ç`useMemo`„ÄÅ`useCallback`Êàñ`useRef`‰πüÊòØÂøÖ‰∏çÂèØÂ∞ëÁöÑ„ÄÇ

ËøòÊúâ[Âè¶‰∏ÄÁ´†Âè´ÂÅö**È´òÁ∫ßÊåáÂçó**](https://reactjs.org/docs/accessibility.html)ÔºåÊàë‰∏çËÆ§‰∏∫ËøôÊòØÂºÄÂßãÊó∂ÁöÑÂøÖ‰øÆËØæÔºå‰ΩÜÊàëÂº∫ÁÉàÂª∫ËÆÆ‰Ω†Âú®ReactÊóÖÁ®ã‰∏≠ÊéåÊè°Ëøô‰∫õÊ¶ÇÂøµ„ÄÇ

‰∏ÄÂ¶ÇÊó¢ÂæÄÔºåÂΩì‰Ω†Â∑≤ÁªèÊúâ‰∏Ä‰∫õÂÆûË∑µÁªèÈ™åÊó∂ÔºåÂæÄÂæÄÊõ¥ÂÆπÊòìÁêÜËß£È´òÁ∫ß‰∏ªÈ¢ò„ÄÇ‰ΩÜ‰Ω†Âú®Êó©Êúü‰∫ÜËß£ÁöÑÈÇ£‰∫õ‰∏úË•øË∂äÂ§öË∂äÂ•Ω„ÄÇ

ÂΩìÁÑ∂Ôºå‰Ω†‰∏çÂ∫îËØ•ÊääËá™Â∑±ÈôêÂà∂Âú®Âè™ÈÅµÂæ™ReactÊñáÊ°£‰∏ä„ÄÇÈÄöËøáÊ∂µÁõñËøô‰∫õÊûÑ‰ª∂ÁöÑÂú®Á∫øËØæÁ®ãÔºåËßÇÁúãÊïôÁ®ãÊàñÈòÖËØªÂÖ∂‰ªñÂçöÂÆ¢ÊñáÁ´†‰πüÊòØÊâì‰∏ãÂùöÂÆûÂü∫Á°ÄÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÊâÄ‰ª•ÔºåÊµãËØï‰∏Ä‰∏ã‰ªÄ‰πàÂØπ‰Ω†ÊúÄÊúâÊïà„ÄÇ

Â¶ÇÊûúÊàë‰∏çÂæó‰∏çÈÄâÊã©ÊúÄÈáçË¶ÅÁöÑÊ¶ÇÂøµÊù•‰∫ÜËß£ÔºåÊàë‰ºöÂª∫ËÆÆËøô‰∫õ:

-   ‰ªÄ‰πàÊòØ "state"?
-   Á±ª(class)ÂíåÂäüËÉΩÈÉ®‰ª∂(functional components)ÁöÑËµ∑‰ºèÂèòÂåñ
-   ‰ªÄ‰πàÊòØÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤ÊüìÔºåÂÆÉ‰ª¨ÊòØÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ?
-   Â¶Ç‰ΩïËß¶ÂèëÈáçÊñ∞Ê∏≤Êüì
-   ‰∏çÂêåÁªÑ‰ª∂ÁöÑÁîüÂëΩÂë®Êúü‰ª•ÂèäÂ¶Ç‰Ωï‰∫§‰∫í
-   ËôöÊãüDOM
-   CSRÔºàÂÆ¢Êà∑Á´ØÊ∏≤ÊüìÔºâÂíåSSRÔºàÊúçÂä°Âô®Á´ØÊ∏≤ÊüìÔºâÂú®‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÂíåReact‰∏≠ÁöÑÂ•ΩÂ§Ñ
-   ÂèóÊéßÁªÑ‰ª∂ VS ÈùûÂèóÊéßÁªÑ‰ª∂
-   State ÊèêÂçá
-   Ëá≥Â∞ë‰∏ÄÁßçÂÖ®Â±ÄÁä∂ÊÄÅÁÆ°ÁêÜÊäÄÊúØÔºàContext API, Redux/Toolkit, RecoilÔºâ„ÄÇ
-   ÁªÑ‰ª∂Ê®°ÂºèÔºàÁâπÂà´ÊòØÂ¶Ç‰ΩïÈÄâÊã©Ê≠£Á°ÆÁöÑÊ®°ÂºèÔºâ„ÄÇ

## Learn How to Build Clean, Performant and Maintainable React Components

![wesley-tingey-mvLyHPRGLCs-unsplash](https://www.freecodecamp.org/news/content/images/2022/01/wesley-tingey-mvLyHPRGLCs-unsplash.jpg)

ÊàëÁü•ÈÅì--ËøôÊòØÊØè‰∏™Á®ãÂ∫èÂëòÁöÑÊ¢¶ÊÉ≥ÔºàÊàñËÄÖËá≥Â∞ëÊàëÂ∏åÊúõÊòØËøôÊ†∑Ôºâ„ÄÇËÄåÂØπÊàëÊù•ËØ¥ÔºåËøôÁßçËÉΩÂäõÂ∞Ü‰∏Ä‰∏™Â•ΩÁöÑÁ®ãÂ∫èÂëòÂíå‰∏Ä‰∏™‰ºüÂ§ßÁöÑÁ®ãÂ∫èÂëòÂàÜÂºÄ„ÄÇÊúâË∂£ÁöÑÊòØÔºåÂÆÉ‰ªéÊú™ÁúüÊ≠£ÂÆåÊàêÔºåÂõ†‰∏∫ÊÄªÊúâ‰∏Ä‰∫õ‰∏úË•øÈúÄË¶ÅÂ≠¶‰π†ÂíåÊîπËøõ„ÄÇ

ÈÅµÂæ™Ëøô‰∫õÊúÄ‰Ω≥ÂÆûË∑µ‰∏ç‰ªÖ‰ºöËÆ©‰Ω†Êõ¥ËΩªÊùæÔºå‰πü‰ºöËÆ©‰Ω†ÁöÑÈòüÂèãÊõ¥ËΩªÊùæ„ÄÇÊàëËßÅËøá‰∏Ä‰∫õÂºÄÂèëÂõ¢ÈòüÂàõÂª∫‰∫Ü‰∏Ä‰∏™ _‰ª£Á†ÅÈ£éÊ†ºÊåáÂçó_Ôºå‰ªñ‰ª¨Âú®ÂÖ∂‰∏≠ÂÆö‰πâ‰∫ÜÂÖ≥‰∫é‰ªñ‰ª¨Â¶Ç‰ΩïÁºñÂÜô‰ª£Á†ÅÁöÑÈáçË¶ÅÂü∫Áü≥„ÄÇÂ¶ÇÊûú‰Ω†ÈóÆÊàëÔºåËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ËÅ™ÊòéÁöÑÊÉ≥Ê≥ï„ÄÇ

‰ªñ‰ª¨‰∏≠ÁöÑ‰∏Ä‰∫õ‰∫∫ÊòØ:

-   ‰ΩøÁî®ÂäüËÉΩÁªÑ‰ª∂ÔºàÂ¶ÇÁÆ≠Â§¥ÂáΩÊï∞Ôºâ
-   ‰∏çË¶Å‰ΩøÁî®ÂÜÖËÅîÈ£éÊ†º(inline-styles)
-   ‰øùÊåÅÈÄÇÂΩìÁöÑÂØºÂÖ•ÁªìÊûÑ(È¶ñÂÖàÊòØÁ¨¨‰∏âÊñπÂØºÂÖ•-->‰∏ãÈù¢ÊòØÂÜÖÈÉ®ÂØºÂÖ•)
-   Âú®Êèê‰∫§‰πãÂâçÊ†ºÂºèÂåñ‰Ω†ÁöÑ‰ª£Á†Å

‰ª•Ê≠§Á±ªÊé®„ÄÇ

ÂΩìÁÑ∂Ôºå‰Ω†ÂèØ‰ª•ÊääÂÆÉËØ¥ÂæóÂæàËØ¶ÁªÜ„ÄÇËøôÂèñÂÜ≥‰∫é‰Ω†ÁöÑÂõ¢Èòü„ÄÇÊàë‰∏™‰∫∫‰∏çÂñúÊ¨¢ÈùûÂ∏∏ËØ¶ÁªÜÁöÑÈ£éÊ†ºÊåáÂçóÔºåÂõ†‰∏∫ÊàëËÆ§‰∏∫‰Ωú‰∏∫‰∏Ä‰∏™ÁÜüÁªÉÁöÑÂºÄÂèëËÄÖÔºå‰Ω†Â∫îËØ•ÊúâÊüêÁßçËá™Áî±Ôºå‰∏çÂ∫îËØ•ÂèóÂà∞Â§™Â§öÁöÑÈôêÂà∂„ÄÇ

‰ΩÜ‰∏ÄËà¨Êù•ËØ¥Ôºå‰ª£Á†ÅÈ£éÊ†ºÊåáÂçóÊòØÊ¶ÇËø∞Âíå‰øùÊåÅÊúÄ‰Ω≥ÂÆûË∑µÁöÑÂ•ΩÊñπÊ≥ïÔºåÂπ∂Á°Æ‰øù‰Ω†ÁöÑÂõ¢ÈòüÂú®‰∏Ä‰∫õÈáçË¶ÅÈ¢ÜÂüüÊúâÁõ∏ÂêåÁöÑÁúãÊ≥ï„ÄÇÊàëËÆ§‰∏∫ËøôËÉΩÊûÅÂ§ßÂú∞ÊèêÈ´òÂõ¢ÈòüÂêà‰ΩúÂíå‰∫ßÂá∫„ÄÇ

ËÆ©Êàë‰ª¨Êù•ÁúãÁúãËøô‰∫õÊúÄ‰Ω≥ÂÆûË∑µÂà∞Â∫ïÊòØ‰ªÄ‰πàÔºå‰ª•ÂàõÂª∫Âπ≤ÂáÄ„ÄÅÊÄßËÉΩÂ•Ω„ÄÅÂèØÁª¥Êä§ÁöÑÁªÑ‰ª∂„ÄÇËÆ©Ëá™Â∑±ËàíÊúç‰∏ÄÁÇπÔºåÊãø‰∏ä‰∏úË•øÂÅö‰∏™Á¨îËÆ∞ÔºåÁÑ∂Âêé‰∫´ÂèóÂêß

### üìÅ ÂàõÂª∫‰∏Ä‰∏™ËâØÂ•ΩÁöÑÊñá‰ª∂Â§πÁªìÊûÑ

Âú®‰Ω†ÁöÑReactÂ∫îÁî®Á®ãÂ∫è‰∏≠ÁªÑÁªá‰Ω†ÁöÑÊñá‰ª∂ÂíåÊñá‰ª∂Â§πÂØπ‰∫éÂèØÁª¥Êä§ÊÄßÂíåÂèØÊâ©Â±ïÊÄßÊòØÂøÖÈ°ªÁöÑ„ÄÇ

‰∏Ä‰∏™**Â•ΩÁöÑ**Êñá‰ª∂Â§πÁªìÊûÑÂèñÂÜ≥‰∫é‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫èÁöÑÂ§ßÂ∞èÂíå‰Ω†ÁöÑÂõ¢Èòü„ÄÇÊâÄ‰ª•ÔºåËøôÊ≤°Êúâ‰∏Ä‰∏™ÊôÆÈÅçÁöÑÁ≠îÊ°à„ÄÇÁâπÂà´ÊòØÂõ†‰∏∫ËøôÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÊúâËÆ®ËÆ∫ÊÄßÁöÑËØùÈ¢òÔºå‰πüÂèñÂÜ≥‰∫é‰∏™‰∫∫ÁöÑÂñúÂ•Ω„ÄÇ

‰ΩÜÈöèÁùÄÊó∂Èó¥ÁöÑÊé®ÁßªÔºåÈíàÂØπ‰∏çÂêåËßÑÊ®°ÁöÑÂ∫îÁî®Á®ãÂ∫èÁöÑ‰∏Ä‰∫õÊúÄ‰Ω≥ÂÆûË∑µÂ∑≤ÁªèÂèëÂ±ïËµ∑Êù•„ÄÇ

[ËøôÁØáÂæàÂ•ΩÁöÑÂçöÊñá](https://www.robinwieruch.de/react-folder-structure/)‰ªãÁªç‰∫Ü‰∫îÁßç‰∏çÂêåÁöÑÂ∫îÁî®Á®ãÂ∫èËßÑÊ®°ÔºåÂπ∂‰ªãÁªç‰∫ÜÂ¶Ç‰ΩïÁªÑÁªá‰Ω†ÁöÑÊñá‰ª∂ÂíåÊñá‰ª∂Â§πÁöÑÂ•ΩÊÉ≥Ê≥ï„ÄÇÂú®ËÆ°ÂàíÊàñÂºÄÂßã‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫èÊó∂ÔºåËÄÉËôëÂà∞Ëøô‰∏ÄÁÇπÔºå‰ªéÈïøËøúÊù•Áúã‰ºöÊúâÂæàÂ§ßÁöÑ‰∏çÂêå„ÄÇ

‰∏çË¶ÅËøáÂ∫¶ËÆæËÆ°Ôºå‰ΩÜË¶ÅÂ∞ΩÂäõ‰øùÊåÅ‰∏Ä‰∏™ÈÄÇÂΩìÁöÑÁªìÊûÑÔºåÊúÄÈÄÇÂêà‰Ω†ÁõÆÂâçÁöÑÂ∫îÁî®Âíå‰Ω†ÁöÑÂõ¢ÈòüËßÑÊ®°„ÄÇ

### üëá ‰øùÊåÅÁªìÊûÑÂåñÁöÑÂØºÂÖ•È°∫Â∫è

Â¶ÇÊûú‰Ω†Â∑≤ÁªèÊúâ‰∫Ü‰∏Ä‰∫õReactÁöÑÁªèÈ™åÔºå‰Ω†ÂèØËÉΩÂ∑≤ÁªèÁúãÂà∞‰∫ÜÊúâÂæàÂ§öÂØºÂÖ•ËØ≠Âè•ÁöÑËáÉËÇøÊñá‰ª∂„ÄÇÂÆÉ‰ª¨ÂèØËÉΩËøòÊ∑∑ÊùÇÁùÄÊù•Ëá™Á¨¨‰∏âÊñπÂåÖÁöÑÂ§ñÈÉ®ÂØºÂÖ•ÂíåÂÜÖÈÉ®ÂØºÂÖ•ÔºåÂ¶ÇÂÖ∂‰ªñÁªÑ‰ª∂„ÄÅutilÂáΩÊï∞„ÄÅstylesÁ≠âÁ≠â„ÄÇ

ÁúüÂÆû‰∏ñÁïåÁöÑ‰æãÂ≠ê(Êà™ÂèñÈÉ®ÂàÜ):

```javascript
import React, { useState, useEffect, useCallback } from "react";
import Typography from "@material-ui/core/Typography";
import Divider from "@material-ui/core/Divider";
import Title from "../components/Title";
import Navigation from "../components/Navigation";
import DialogActions from "@material-ui/core/DialogActions"
import { getServiceURL } from '../../utils/getServiceURL";
import Grid from "@material-ui/core/Grid";
import Paragraph from "../components/Paragprah";
import { sectionTitleEnum } from "../../constants";
import { useSelector, useDispatch } from "react-redux";
import Box from "@material-ui/core/Box";
import axios from 'axios';
import { DatePicker } from "@material-ui/pickers";
import { Formik } from "formik";
import CustomButton from "../components/CustomButton";
...
```

ÂÆûÈôÖ‰∏äÔºåËøô‰∫õÂØºÂÖ•ËØ≠Âè•Ë∑®Ë∂ä‰∫Ü55Ë°å„ÄÇ

‰Ω†ÂèØËÉΩËÆ§ËØÜÂà∞ËøôÈáåÁöÑÈóÆÈ¢ò„ÄÇÂæàÈöæÂå∫ÂàÜ‰ªÄ‰πàÊòØÊâÄÊúâÁöÑÁ¨¨‰∏âÊñπÂíåÊú¨Âú∞ÔºàÂÜÖÈÉ®ÔºâÂØºÂÖ•„ÄÇÂÆÉ‰ª¨Ê≤°ÊúâË¢´ÂàÜÁªÑÔºå‰ºº‰πéÂà∞Â§ÑÈÉΩÊòØ„ÄÇ

Êõ¥Â•ΩÁöÑÁâàÊú¨:

```javascript
import React, { useState, useEffect, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import { Formik } from "formik";
import axios from 'axios';
import Typography from "@material-ui/core/Typography";
import Divider from "@material-ui/core/Divider";
import Box from "@material-ui/core/Box";
import DialogActions from "@material-ui/core/DialogActions";
import Grid from "@material-ui/core/Grid";
import { DatePicker } from "@material-ui/pickers";

import { getServiceURL } from '../../utils/getServiceURL";
import { sectionTitleEnum } from "../../constants";
import CustomButton from "../components/CustomButton";
import Title from "../components/Title";
import Navigation from "../components/Navigation";
import Paragraph from "../components/Paragraph";
...
```

ÁªìÊûÑÊõ¥Ê∏ÖÊô∞‰∫ÜÔºåËÄå‰∏îÈùûÂ∏∏ÂÆπÊòìÂå∫ÂàÜÂ§ñÈÉ®ÂíåÂÜÖÈÉ®ÂØºÂÖ•ÁöÑ‰ΩçÁΩÆ„ÄÇÂΩìÁÑ∂ÔºåÂ¶ÇÊûú‰Ω†‰ΩøÁî®Êõ¥Â§öÁöÑÂëΩÂêçÂØºÂÖ•Ôºå‰Ω†ÂèØ‰ª•ÂØπÂÆÉËøõË°åÊõ¥Â§öÁöÑ‰ºòÂåñÔºàÂ¶ÇÊûúÊúâÂèØËÉΩÁöÑËØùÔºÅ:) Ôºâ„ÄÇËøôÊ†∑‰Ω†Â∞±ÂèØ‰ª•Âú®‰∏ÄË°å‰∏≠ÂØºÂÖ•ÊâÄÊúâÊù•Ëá™ material-ui ÁöÑÁªÑ‰ª∂„ÄÇ

ÊàëËßÅËøáÂÖ∂‰ªñÂºÄÂèëËÄÖÂñúÊ¨¢ÊääÂØºÂÖ•ÁªìÊûÑÂàÜÊàê‰∏â‰∏™‰∏çÂêåÁöÑÈÉ®ÂàÜ:

ÂÜÖÁΩÆÁöÑÔºàÂ¶Ç'react'Ôºâ-->Â§ñÈÉ®ÔºàÁ¨¨‰∏âÊñπnodeÊ®°ÂùóÔºâ-->ÂÜÖÈÉ®„ÄÇ

‰Ω†ÂèØ‰ª•ÊØèÊ¨°ÈÉΩËá™Â∑±ÁÆ°ÁêÜÔºåÊàñËÄÖËÆ©**linter**ÂÅöËøô‰∏™Â∑•‰Ωú„ÄÇ[ËøôÈáåÊòØ](https://dev.to/otamnitram/sorting-your-imports-correctly-in-react-213m)‰∏ÄÁØáÂÖ≥‰∫éÂ¶Ç‰Ωï‰∏∫‰Ω†ÁöÑReactÂ∫îÁî®ÈÖçÁΩÆlinter‰ª•‰øùÊåÅÊ≠£Á°ÆÁöÑÂØºÂÖ•ÁªìÊûÑÁöÑÂ•ΩÊñáÁ´†„ÄÇ

### üìî Learn different component patterns

To ensure you don't end up with unmaintainable and unscalable spaghetti code, learning different component patterns is essential as you become more experienced in React.

But this is not all. Knowing the different patterns is a good foundation. But the most important aspect about it is that you know **when** to use which pattern for your problem.

Every pattern serves a certain purpose. For example the **compound component pattern** avoids unnecessary _prop-drilling_ of many component levels. So, the next time you begin to do pass props through five component levels to finally reach the component that is interested in the props, you start to orchestrate the components differently.

One quick side note here about props-drilling, because I've had many discussions about it in the past. There're many opinions out there as to whether it's bad or not. As for me, I like to try to think about a different way / pattern if I start to pass props through more than two component levels.

This fact makes you more efficient as a developer and makes the components you write more maintainable or scalable. Having those patterns in your toolkit makes you also stand out from other React developers. I highly encourage you to do your own research, but [this](https://www.udemy.com/course/the-complete-guide-to-advanced-react-patterns/) Udemy course helped me very much.

### üîíUse a linter and follow its rules

A linter doesn't only help you in terms of maintaining a distinguishable import order of your dependencies. It helps you write better code in general.

When you're using _create-react-app_, there's already ESLint configured, but you can also set it up completely on your own or extend the rules of a pre-configured ruleset.

A linter basically observes the JavaScript code you're writing and reminds you of errors you'd more likely catch when executing the code. It took a while for me to really value the use of a linter, but today I can't imagine working without it.

Having the linter is one thing, but following its rules is another. Of course you can disable it. Either for a specific line of code or for the whole file itself. There may be cases where this makes sense, but from my experience they're pretty rare.

Another great benefit is that you can also adjust style checking. This is especially helpful for teams. Once you agreed upon certain conventions of how you write your code and how it should be formatted, you can easily combine ESLint with something like JSPrettify.

### üß™ Test your code

I know, testing is likely not your favorite task as a developer. I used to be like that. At the beginning it seemed to be an unnecessary and disturbing task. This might be true for the short run. But in the long run ‚Äì and when the application grows ‚Äì it is vital.

For me, testing has become a practice that ensures I'm doing my job more professionally and delivering higher quality software.

Basically there's nothing wrong with manual testing by a human and that shouldn't be avoided completely. But imagine you're integrating a new feature and want to make sure that nothing is broken. This can be a time consuming task and is prone to human error.

During the time you're writing tests you're already in the thinking process of how to organize your code in order to pass this test. For me this is always helpful because I recognize what pitfalls might arise and that I have to keep an eye on them.

You're not directly jumping into writing your code either (which I wouldn't recommend at all), but you're thinking first about the goal.

For example "What should that particular component do? What important edge cases might arise that I have to test? Can I make the component more pure that it only serves one purpose? ..."

Having a vision for the code you're about to write also helps you to maintain a sharp focus on serving that vision. ¬†

Tests can also serve as a kind of documentation, because for a new developer who is new to the codebase it can be very helpful to understand the different parts of the software and how they're expected to work.

So, don't avoid testing because it seems to be _extra work._ The reality is that it can save you extra work in the future when you set it up properly.

Take a look at the ["Testing" chapter inside the React Docs](https://reactjs.org/docs/testing.html), go through a few tutorials on testing in React, and just start writing your first small TDD application or implement tests into an app you're currently working on.

### üß∞ Integrate Typescript (or at least use default props and prop types)

I remember my first React project as a software developer where our team received a project that was already basically written by another company. Then we had to build the client's project upon it, and Typescript had already been integrated.

Up to that point, my teammates and I hadn't had much experience in TypeScript since we all came from a vanilla JavaScript background.

After a few weeks of working with that project, we felt that TypeScript wasn't a benefit, but more an obstacle that blocked us in our workflow. We also weren't really using the benefits of it because we defined everything with type _any_ to suppress the Typescript warnings.

That led us to the decision to remove TypeScript from the project and to work on our known terrain with vanilla JavaScript. This went well at first, but the more complex our project became, the more type errors emerged. So we doubted our decision a lot of getting completely rid of TypeScript. But those things can happen and gave us valuable experiences for the future.

This circumstance led me to give TypeScript another chance, and I learned it in my spare time. After building some side projects with it, I can't imagine a life without it anymore.

Using TypeScript has many upsides like static type checking, better code completion in your IDE (intellisense), improved developer experience, and catching type errors while you write the code ‚Äì just to name a few.

On the other hand it can have some challenges of course, because if you're not coming from a background with strongly typed languages (like Java or C#) it might be harder at the beginning to grasp it.

But I can say that it's really worth it to learn and to integrate it. [Here's](https://blog.bitsrc.io/5-strong-reasons-to-use-typescript-with-react-bc987da5d907) a nice article that can help you out of getting an overview of the ups and downs using Typescript in React applications. And [here's a tutorial](https://www.freecodecamp.org/news/how-to-code-your-react-app-with-typescript/) on how to code your React apps in TypeScript.

There may be reasons you don't want to use TypeScript inside your React application. That's fine. But at a bare minimum I'd recommend that you use **prop-types** and **default-props** for your components to ensure you don't mess up your props.

### üíé Use lazy-loading / code splitting

If you've spent some time in the JavaScript and React universe, you've most likely stumbled across **bundling**. For those of you who are hearing this term for the first time, let's see what the official React docs say:

> Most React apps will have their files ‚Äúbundled‚Äù using tools like Webpack, Rollup or Browserify. Bundling is the process of following imported files and merging them into a single file: a ‚Äúbundle‚Äù. This bundle can then be included on a webpage to load an entire app at once.

Basically this is a great technique, but with the growth of your app comes a challenge. Your bundle starts growing as well. Especially when you're using big third-party libraries like three.js.

The pitfall is that this bundle needs to be always loaded completely, even when the user needs only a fraction of the code. This leads to performance issues because it can take an unnecessarily long time to load up your app.

To avoid this, there's a technique called **code splitting** where you split up your bundle into the pieces of the code your user needs. This is supported by the most common bundlers like Webpack, Rollup, and Browserify. The great benefit of it is that you can create multiple bundles and load them dynamically.

Splitting up your bundle helps you to **lazy load** only the things that are needed by the user.

To illustrate this, imagine you're going into a grocery store and just want to grab some bananas, apples, and bread. In that case you aren't buying the whole range of the store and then grab your bananas, apples and bread out of it. You're just interested in a fraction of the range. So why would you buy everything? It would take way longer and is of course more expensive.

I think it's important to be aware of the potential challenges that can arise as your app grows, and that there are certain techniques at hand to get rid of those issues. For further reading checkout the [React docs.](https://reactjs.org/docs/code-splitting.html)

### üóÑÔ∏è Extract reusable logic into custom hooks

According to the React docs,

> _Hooks allow us to reuse stateful logic without changing our component hierarchy._

Basically they're a better solution to the techniques that were used before in combination with class components. If you've been coding for a while, you might remember the use of **Higher Order Components** or **render props.**

Whenever you find yourself in a situation where you have to reuse the same stateful logic that is already used in another functional component, that's a great time to create a custom hook. Inside it you encapsulate the logic and just have to call the hook as a function inside your components.

Let's take a look at a quick example where we need to update our UI according to the screen size and want to keep track of the current window size when resizing the browser window manually.

```jsx
const ScreenDimensions = () => {
  const [windowSize, setWindowSize] = useState({
    width: undefined,
    height: undefined,
  });
  
  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return (
  	<>
    	<p>Current screen width: {windowSize.width}</p>
        <p>Current screen height: {windowSize.height}</p>
    </>
  )
}
```

Thanks to: https://usehooks.com/useWindowSize/

As you can see, the solution is pretty straightforward and there's nothing wrong with defining it like this.

Now comes the tricky part. Imagine we'd like to use the exact logic in another component, where we'll render a different UI (one for smartphones and one for desktops) based on the current screen size.

Of course we could just copy the logic, paste it in and we're done. But this is not a good practice, as you might know from the DRY principle.

If we'd like to adjust our logic, we have to do it in both components. And when we paste our logic in even more components, it becomes less maintainable and more error prone.

So, what would you normally do in a vanilla JavaScript project? You'd most likely define a function that encapsulates the logic and can be used in many different places. That's exactly what we'll achieve with hooks. They are nothing more than JavaScript functions but with some React specialities because they're using React hooks.

Let's see how our custom hook would look:

```jsx
const useWindowSize = () => {
  const [windowSize, setWindowSize] = useState({
    width: undefined,
    height: undefined,
  });
  
  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return windowSize;
}
```

Now let's simply call it inside our **ScreenDimensions** component:

```jsx
const ScreenDimensions = () => {
  const windowSize = useWindowSize()
  
  return (
  	<>
    	<p>Current screen width: {windowSize.width}</p>
        <p>Current screen height: {windowSize.height}</p>
    </>
  )
}
```

This enables us to just call the custom hook in any other component and save the return value (which is the current window size) in a variable that we can use inside the component.

```jsx
const ResponsiveView = () => {
  const windowSize = useWindowSize()
  
  return (
  	<>
    	{windowSize.width <= 960 ? (
          <SmartphoneView />
        ) : (
          <DesktopView />	
        )}
    </>
  )
}
```

### üñ•Ô∏è Handle errors effectively

Handling errors effectively is often overlooked and underestimated by many developers. Like many other best practices this seems to be an afterthought at the beginning. You want to make the code work and don't want to "waste" time thinking much about errors.

But once you've become more experienced and have been in nasty situations where better error handling could have saved you a lot of energy (and valuable time of course), you realize that it's mandatory in the long run to have a solid error handling inside your application. Especially when the application is deployed to production.

But what exactly does _error handling_ mean in the React world? There are some different parts that play a role. One is to **catch** errors, another one to **handle** the UI accordingly, and the last one to **log** them properly.

#### React Error Boundary

This is a custom class component that is used as a wrapper of your entire application. Of course you can wrap the ErrorBoundary component also around components that are deeper in the component tree to render a more specific UI, for example. Basically it's also a best practice to wrap the ErrorBoundary around a component that is error prone.

With the lifecycle method `componentDidCatch()` you're able to catch errors during the rendering phase or any other lifecycles of the child components. So when an error arises during that phase, it bubbles up and gets caught by the ErrorBoundary component.

If you're using a logging service (which I also highly recommend), this is a great place to connect to it.

The static function `getDerivedStateFromError()` is called during the render phase and is used to update the state of your ErrorBoundary Component. Based on your state, you can conditionally render an error UI.

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    //log the error to an error reporting service
    errorService.log({ error, errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return <h1>Oops, something went wrong.</h1>;
    }
    return this.props.children; 
  }
}
```

The big drawback of this approach is that it doesn't handle errors in asynchronous callbacks, on server-side-rendering, or in event-handlers because they're outside the boundary.

#### Use try-catch to handle errors beyond boundaries

This technique is effective to catch errors that might occur inside asynchronous callbacks. Let's imagine we're fetching a user's profile data from an API and want to display it inside a Profile Component.

```jsx
const UserProfile = ({ userId }) => {
	const [isLoading, setIsLoading] = useState(true)
	const [profileData, setProfileData] = useState({})
    
    useEffect(() => {
    	// Separate function to make of use of async
        const getUserDataAsync = async () => {
        	try {
            	// Fetch user data from API
            	const userData = await axios.get(`/users/${userId}`)
                // Throw error if user data is falsy (will be caught by catch)
                if (!userData) {
                	throw new Error("No user data found")
                }
                // If user data is truthy update state
                setProfileData(userData.profile)
            } catch(error) {
            	// Log any caught error in the logging service
            	errorService.log({ error })
                // Update state 
                setProfileData(null)
            } finally {
            	// Reset loading state in any case
                setIsLoading(false)
            }
        }
        
        getUserDataAsync()
    }, [])
    
    if (isLoading) {
    	return <div>Loading ...</div>
    }
    
    if (!profileData) {
    	return <ErrorUI />
    }
    
    return (
    	<div>
        	...User Profile
        </div>
    )
}
```

When the component gets mounted, it starts a GET request to our API to receive the user data for the corresponding userId that we'll get from the props.

Using try-catch helps us catch any error that might occur during that API call. For example this could be a 404 or a 500 response from the API.

Once an error gets caught, we're inside the catch block and receive the error as a parameter. Now we're able to log it in our logging service and update the state accordingly to display a custom error UI.

#### Use the react-error-boundary library (personal recommendation)

This library basically melts those two techniques from above together. It simplifies error handling in React and overcomes the limitations of the ErrorBoundary component we've seen above.

```jsx
import { ErrorBoundary } from 'react-error-boundary'

const ErrorComponent = ({ error, resetErrorBoundary }) => {
  
  return (
    <div role="alert">
      <p>Something went wrong:</p>
      <pre>{error.message}</pre>
    </div>
  )
}

const App = () => {
  const logError = (error, errorInfo) => {
  	errorService.log({ error, errorInfo })
  }
  

  return (
    <ErrorBoundary 
       FallbackComponent={ErrorComponent}
       onError={logError}
    >
       <MyErrorProneComponent />
    </ErrorBoundary>
  );
}
```

The library exports a component that is made up of the ErrorBoundary functionality we already know and adds some nuances to it. It allows you to pass a `FallbackComponent` as a prop that should be rendered once an error got caught.

It also exposes a prop `onError` which provides a callback function when an error arises. It's great for using it to log the error to a logging service.

There are some other props that are quite useful. If you'd like to know more, feel free to checkout [the docs.](https://www.npmjs.com/package/react-error-boundary?activeTab=readme)

This library also provides a hook called `useErrorHandler()` that is meant to catch any errors that are outside the boundaries like event-handlers, in asynchronous code and in server-side-rendering.

#### Logging errors

Catching and handling errors effectively is one part, logging them properly is another. Once you've set up your error handling inside your application, you need to log them persistently.

The most frequently used way is the good old **console.log**. This might be good during development when you want a quick log, but once your application is deployed to production it becomes useless. This is because you only see the error inside the user's browser, which is not effective at all.

When logging errors in production, **you** as the developer want to see the errors in one dedicated place in order to fix them.

For that reason we need a logging service created by our own or a third-party one.

When using third-party logging services my personal recommendations is definitely **Sentry.** So I highly encourage you to check it out.

### ‚òùÔ∏è Keep your key prop unique across your whole app

When mapping over an Array to render its data, you always have to define a **key** property for each element. A common practice I've seen and used myself as well is to use simply the **index** of each element as the key prop.

Using the key prop is important because it helps React to identify the exact element that has changed, is added or is removed. Imagine the state of your component changes and the UI needs to be re-rendered with the new state. React needs to figure out the differences between the previous UI and new UI in order to update it.

"What elements are added/removed or have changed?"

Therefore the key prop has to be unique. Using the index of the current element makes sure that it is only unique in this particular map function.

It could look like this, if we'd pretend to show a score history of a football team from the current season:

```jsx
const SeasonScores = ({ seasonScoresData }) => {
	
    return (
    	<>
        	<h3>Our scores in this season:<h3>
        	{seasonScoresData.map((score, index) => (
    			<div key={index}>
        			<p>{score.oponennt}</p>
        			<p>{score.value}</p>
        		</div>
    		))}
        </>
    )
}
```

While this is only unique inside this map function here, this could lead to potential issues. It's pretty common to have more than one map function inside your React application or even in one component.

Let's assume we've got another map-function in our component to display the current roster:

```jsx
const SeasonScores = ({ seasonScoresData, currentRoster }) => {
	
    return (
    	<>
        	<h3>Our scores in this season:<h3>
        	{seasonScoresData.map((score, index) => (
    			<div key={index}>
        			<p>{score.oponennt}</p>
        			<p>{score.value}</p>
        		</div>
    		))}
            </br>
			<h3>Our current roster:<h3>
        	{currentRoster.map((player, index) => (
            	<div key={index}>
                	<p>{player.name}</p>
                    <p>{player.position}</p>
                    <p>{player.jerseyNumber}</p>
                    <p>{player.totalGoals}</p>
                </div>
    		))}
        </>
    )
}
```

Now we end up in the situation where we used many keys twice inside our component. Let's assume we got **14** elements inside `seasonScoresData` and **30** in `currentRoaster`. We have used the numbers 0-13 two times as a key prop. Now we're not serving the purpose anymore to have unique key props.

This could lead to potential problems because React might only re-render only one item and omit the other one. Or it can lead to inefficiencies with updating the UI tree. Check out the recommended blog post at the end of this tip to get a more in depth example.

To avoid this unwanted behavior, make sure to always use **unique keys across your whole application.** Ideally each item in the Array has got its own unique id that you can use. But this isn't always the case, so you can use an external library like **uuidv4** for generating unique id's.

With that in mind and with the assumption that every item in both Arrays has an id property, the component would look like this:

```jsx
const SeasonScores = ({ seasonScoresData, currentRoster }) => {
	
    return (
    	<>
        	<h3>Our scores in this season:<h3>
        	{seasonScoresData.map((score, index) => (
    			<div key={score.id}>
        			<p>{score.oponennt}</p>
        			<p>{score.value}</p>
        		</div>
    		))}
            </br>
			<h3>Our current roster:<h3>
        	{currentRoster.map((player, index) => (
            	<div key={player.id}>
                	<p>{player.name}</p>
                    <p>{player.position}</p>
                    <p>{player.jerseyNumber}</p>
                    <p>{player.totalGoals}</p>
                </div>
    		))}
        </>
    )
}
```

If you want to go into more depth, feel free to check out [this great post](https://medium.com/swlh/understanding-the-importance-of-the-key-prop-in-react-f2b92ce65f45) about that topic.

## Tips to Help You Write Better React Code,  The Cherries on Top

![joanna-kosinska-_xN7UbcZ33I-unsplash](https://www.freecodecamp.org/news/content/images/2022/01/joanna-kosinska-_xN7UbcZ33I-unsplash.jpg)

I'd like to compare this guide to the process of building a house. The first part, _Learn the Building Blocks of React_, is the solid foundation you build your application on. The second one, _How to Build Clean, Performant and Maintainable React Components_, is for building the walls.

This section is basically the roof that comes on top to complete the house. That's the reason I'd like to call it _Cherries on Top_. These tips here are more granular.

Most of these practices are more optional than those before, but can make a difference if you use them properly.

### ü™Ñ Implement the useReducer hook earlier

Probably one of the most frequently used hooks in React is **useState**. I've created and seen components over the time that have got a lot of different states. So it's natural that they become flooded with a lot of useState hooks.

```jsx
const CustomersMap = () => {
  const [isDataLoading, setIsDataLoading] = useState(false)
  const [customersData, setCustomersData] = useState([])
  const [hasError, setHasError] = useState(false)
  const [isHovered, setIsHovered] = useState(false)
  const [hasMapLoaded, setHasMapLoaded] = useState(false)
  const [mapData, setMapData] = useState({})
  const [formData, setFormData] = useState({})
  const [isBtnDisabled, setIsBtnDisabled] = useState(false)
  
  ...
  
  return ( ... )
}
```

Having a lot of different useState hooks is always a great sign that the size and therefore the complexity of your component is growing.

If you can create some smaller sub components where you can transfer some state and JSX in, then this is a great way to go. So you're cleaning up your useState hooks and your JSX in one step.

In our example above, we could put the last two states into a separate component that handles all state and JSX that has to do with a form.

But there are scenarios where this doesn't make sense, and you have to keep those many different states inside one component. To increase the legibility of your component, there is the **useReducer** hook.

The official React docs say this about it:

> `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.

With that in mind, the component would like this when using `useReducer`:

```jsx
// INITIAL STATE
const initialState = {
  isDataLoading: false,
  customerData: [],
  hasError: false,
  isHovered: false,
  hasMapLoaded: false,
  mapData: {},
  formdata: {},
  isBtnDisabled: false
}

// REDUCER
const reducer = (state, action) => {
  switch (action.type) {
    case 'POPULATE_CUSTOMER_DATA':
      return {
        ...state,
        customerData: action.payload
      }
    case 'LOAD_MAP':
      return {
        ...state,
        hasMapLoaded: true
      }
    ...
    ...
    ...
    default: {
      return state
    }	
  }
}

// COMPONENT
const CustomersMap = () => {
  const [state, dispatch] = useReducer(reducer, initialState)
  
  ...
  
  return ( ... )
}
```

The component itself looks cleaner and comes along with some great benefits as you can see inside the docs. If you're used to Redux, the concept of a reducer and how it is built isn't new to you.

My personal rule is to implement the useReducer hook if my component exceeds four useState hooks, or if the state itself is more complex than just a boolean, for example. It might be an object for a form with some deeper levels inside.

### üîå Use shorthand for boolean props

Often there are scenarios where you pass boolean props to a component. I've seen a lot of developers doing it like this:

```jsx
<RegistrationForm hasPadding={true} withError={true} />
```

But you don't need to do it necessarily like this because the occasion of the prop itself is either truthy (if the prop is passed) or falsy (if the prop is missing).

A cleaner approach would be:

```jsx
<RegistrationForm hasPadding withError />
```

### üëé Avoid curly braces for string props

A similar use case like we've seen in the tip before is using string props:

```jsx
<Paragraph variant={"h5"} heading={"A new book"} />
```

You don't need the curly braces in that case because you're allowed to directly use strings inside your props. When you want to attach a className to a JSX Element you're most likely using it also directly as a string.

When you'd like use a JavaScript expression different from a string, you need to use the curly braces. For example if you want to use a number or an object. This is also true for template strings (don't get caught up like I did many times, haha).

With plain strings, like in the example, it would look like this:

```jsx
<Paragraph variant="h5" heading="A new book" />
```

### üßπ Erase non-html attributes when spreading props

Let's take a look at a quick example:

```jsx
const MainTitle = ({ isBold, children, ...restProps }) => {
	
  return (
    <h1 
      style={{ fontWeight: isBold ? 600 : 400 }}
      {...restProps}
    >
      {children}
    </h1>
  )
}
```

We've just created a component that will render a h1 tag, extracted some props, and spread out all other potential props on the h1 tag. So far, so good.

Now, we're able to use it in other components and can trigger manually if the h1 should be bold or not:

```jsx
// WITH BOLD TITLE
const IndexPage = () => {
	
  return (
    <>
      <MainTitle isBold>
        Welcome to our new site!
      </MainTitle>
      ...
    </>
  )
}
```

```jsx
// WITHOUT BOLD TITLE
const AboutPage = () => {
	
  return (
    <>
      <MainTitle>
      	Some quick lines about us!
      </MainTitle>
      ...
    </>
  )
}
```

Up to now, everything works perfectly without any errors or warnings. The interesting part starts now when we're using other props that are directly spread onto the h1 tag.

When you're using valid HTML attributes like id or a class, everything works without any error (remember --> "className" will become "class"):

```jsx
const IndexPage = () => {
	
  return (
    <>
      <MainTitle isBold id="index-main-title" className="align-left">
        Welcome to our new site!
      </MainTitle>
      ...
    </>
  )
}
```

So all props above will be added as an attribute to the h1 because we're using **{...restProps}** on it. No matter what, props we are adding and NOT extracting will be added to the h1 tag.

This is great for many use cases but can be a problem at the same time:

```jsx
// Page Component
const IndexPage = () => {
	
  return (
    <>
      <MainTitle isBold hasPadding>
        Welcome to our new site!
      </MainTitle>
      ...
    </>
  )
}

// MainTitle Component
const MainTitle = ({ isBold, children, ...restProps }) => {
	
  return (
    <h1 
      style={{ 
        fontWeight: isBold ? 600 : 400,
        padding: restProps.hasPadding ? 16 : 0
      }}
      {...restProps}
    >
      {children}
    </h1>
  )
}
```

In the code above we were adding a new prop called `hasPadding` to the `MainTitle` component, that is optional. Inside the component we are not extracting it from the props and call it via `restProps.hasPadding`.

The code works, but when you open your browser you'll receive a warning that `hasPadding` is a non-HTML attribute you're trying to apply on the h1 tag. This is because of `{...restProps}` on the h1 tag and not extracting `hasPadding` like `isBold` for example.

To avoid this, always extract all non-HTML attributes from the props first, to make sure that there are only valid HTML attributes in `restProps` that you're spreading onto a JSX element.

In our example it would look like this:

```jsx
// Page Component
const IndexPage = () => {
	
  return (
    <>
      <MainTitle isBold hasPadding>
        Welcome to our new site!
      </MainTitle>
      ...
    </>
  )
}

// MainTitle Component
const MainTitle = ({ isBold, children, hasPadding, ...restProps }) => {
	
  return (
    <h1 
      style={{ 
        fontWeight: isBold ? 600 : 400,
        padding: hasPadding ? 16 : 0
      }}
      {...restProps}
    >
      {children}
    </h1>
  )
}
```

Many of those warnings can unnecessary flood your browser's console, which can be very nasty. Especially when you're debugging.

To get more information about this topic and some other ways to solve this, check out [this part of the React docs](https://reactjs.org/warnings/unknown-prop.html).

### üî• Use snippet extensions

In Visual Studio Code, for example, there are certain extensions available that increase your productivity a lot. One type of these extensions are **snippet extensions.**

The great benefit about them is that you don't have to write all that boilerplate code again. Imagine you're building many new components and have to type it all out again and again:

```jsx
import React from 'react'

const GoogleMap = () => {

}

export default GoogleMap
```

With these snippets you just have to type **`rafce`,** for example, hit tab and you have the same boilerplate code. It is a real time saver and makes development faster.

**But use them with caution!** I wouldn't recommend using snippets to all developers. In my opinion, beginners shouldn't use any snippets and should type the boilerplate out by hand. When you're doing that, you'll get muscle memory which manifests the stuff you learn.

If you have done it so often that you can type it out in your sleep and it becomes boring, that's the right time to use snippets.

Here are my recommendations:

![Bildschirmfoto-2022-02-01-um-14.55.02](https://www.freecodecamp.org/news/content/images/2022/02/Bildschirmfoto-2022-02-01-um-14.55.02.png)

![Bildschirmfoto-2022-02-01-um-15.05.01](https://www.freecodecamp.org/news/content/images/2022/02/Bildschirmfoto-2022-02-01-um-15.05.01.png)

![Bildschirmfoto-2022-02-01-um-15.06.59](https://www.freecodecamp.org/news/content/images/2022/02/Bildschirmfoto-2022-02-01-um-15.06.59.png)

### ‚ùå Write a fragment when a div is not needed

A React component can only render one single HTML tag at its root. So if you'd like to render two adjacent elements, you'll get the famous error called **Adjacent JSX elements must be wrapped in an enclosing tag**.

```jsx
const InfoText = () => {
	
  // Will throw an error
  return (
    <h1>Welcome!</h1>
    <p>This our new page, we're glad you're are here!</p>
  )
}
```

So, what can you do? You just wrap the rendered output into a fragment, which satisfies React and doesn't render an extra HTML element in the browser.

```jsx
const InfoText = () => {
	
  return (
  	<>
      <h1>Welcome!</h1>
      <p>This our new page, we're glad you're are here!</p>
    </>
  )
}
```

Of course you could have solved this with a div tag as well. But using div after div will create something I like to call **div hell** in the browser where you got many deep nested div tags without any sense.

So whenever you have to use a wrapper tag in React but don't necessarily need an HTML tag, then simply use a fragment.

### üëà Integrate self closing tags when no children are needed

From my experience, this tip right here is often overlooked, but could make your code so much cleaner with little effort.

In React you've got the opportunity to pass children elements to a component, which are then available to the component via its children property. Those components are often called **composite components.**

In that case you have to use an opening tag and a closing tag of course:

```jsx
<NavigationBar>
  <p>Home</p>
  <p>About</p>
  <p>Projects</p>
  <p>Contact</p>
</NavigationBar>
```

But when there are no children needed, there isn't any sense in using an opening and closing tag, right?

```jsx
<NavigationBar></NavigationBar>
```

Instead of doing this, I recommend that you just use the component as a self closing element like the input tag in HTML, that doesn't take children as well.

```jsx
<NavigationBar />
```

Looks much cleaner right away, doesn't it?

### ‚úÖ Follow common naming conventions

The sense behind naming conventions is to more easily recognize what type of element you're dealing with and to have something in your code that is common in the community.

From my standpoint, there are two major naming conventions involved in React and JavaScript that you should follow:

#### Use PascalCase in components, interfaces, or type aliases

```jsx
// React component
const LeftGridPanel = () => {
  ...
}

// Typescript interface
interface AdminUser {
  name: string;
  id: number;
  email: string;
}

// Typescript Type Alias
type TodoList = {
	todos: string[];
    id: number;
    name: string;
}

```

#### Use camelCase for JavaScript data types like variables, arrays, objects, functions, and so on

```jsx
const getLastDigit = () => { ... }

const userTypes = [ ... ]

```

Naming React components in PascalCase is especially important. Because when you've got a linter configured for React, but you named the component in camelCase and you're using hooks inside it, you'll get a warning message all the time that hooks are only allowed in components. That's because the linter recognizes a React components if it's written in PascalCase or not.

This can be nasty, but is fixed quickly with sticking to the established naming conventions.

### üß® Sanitize your code to prevent XSS Attacks

Maybe you've found yourself in a scenario where you have to use the property `dangerouslySetInnerHTML` on an element in React. Basically it's React's equivalent to `innerHTML` you might know from Javascript.

So using it, you can set HTML directly from React.

Let's consider the following example, where we'd like to render an HTML string inside a div. The string could come from a rich text editor where it's already formatted HTML.

```jsx
const Markup = () => {
  const htmlString = "<p>This is set via dangerouslySetInnerHTML</p>"
  
  return (
    <div dangerouslySetInnerHTML={{ __html: htmlString }} />
  )
}
```

The term **dangerously** is chosen with intention. Using this property can open you up to a cross-site-scripting (XSS) attack. So it's mandatory that the code that gets set is sanitized first.

A great library is **[dompurify](https://www.npmjs.com/package/dompurify)** that can help you out with this.

## Final words

Wow, that was fun right? I tried my best to let everything out that got piled up over the past in my head. My motivation behind this guide is to share my experience with you so you can avoid some harder times during your React learning and development.

Of course there might be best practices you consider more important that I've missed here. That's great. I'd love to hear what you'd like to add to this guide.

Remember, it's always all about adapting what's useful for you. So, don't take it all for granted and think about what might be helpful in your situation. Then you can just add it to your own stack of best practices.

You can also follow my developer journey and get many more useful insights about the life of a developer on my [Instagram Profile](https://www.instagram.com/jean_marc.dev/). I'm always there to help you and happy about every feedback I can get. So, feel free to reach out.