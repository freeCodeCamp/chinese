> -  原文地址：[How to Learn to Code & Get a Developer Job in 2023 [Full Book]](https://www.freecodecamp.org/news/learn-to-code-book/)
> -  原文作者：[Quincy Larson](https://www.freecodecamp.org/news/author/quincylarson/)
> -  译者：casey cui
> -  校对者：

![How to Learn to Code & Get a Developer Job in 2023 [Full Book]](https://www.freecodecamp.org/news/content/images/size/w2000/2023/01/Learn-to-Code-and-Get-a-Developer-Job-Book.jpg)

If you want to learn to code and get a job as a developer, you're in the right place. This book will show you how.

And yes this is the full book – for free – right here on this webpage.

A few years back, one of the Big 5 book publishers from New York City reached out to me about a book deal. I met with them, but didn't have time to write a book.

Well, I finally had time. And I decided to just publish this book for free, right here on freeCodeCamp.

Information wants to be free, right? 🙂

It may take you a few hours to read all this. But this is it. My insights into learning to code and getting a developer job.

I learned all of this while:

- learning to code in my 30s
- then working as a software engineer
- then running freeCodeCamp.org for the past 8 years. Today, more than a million people visit this website each day to learn about math, programming, and computer science.

I was an English teacher who had never programmed before. And I was able to learn enough coding to get my first software development job in just one year.

All without spending any money on books or courses.

(I did spend money to travel to nearby cities and participate in tech events. And as you'll see later in the book, this was money well spent.)

After working as a software engineer for a few years, I felt ready. I wanted to teach other people how to make this career transition, too.

I built several technology education tools that nobody was interested in using. But then one weekend, I built freeCodeCamp.org. A vibrant community quickly gathered around it.

Along the way, we all helped each other. And today, people all around the world have used freeCodeCamp to prepare for their first job in tech.

You may be thinking: I don't know if I have time to read this entire book.

No worries. You can bookmark it. You can come back to it and read it across as many sittings as you need to.

And you can share it on social media. Sharing: "check out this book I'm reading" and linking to it is a surprisingly effective way to convince yourself to finish reading a book.

I say this because I'm not trying to sell you this book. You already "bought" this book when you opened this webpage. Now my goal is to reassure you that this book **will** be worth investing your scarce time in finish. 😉

I promise to be respectful of your time. There's no hype or fluff here – just blunt, actionable tips.

I'm going to jam as much insight as I can into every chapter of this book.

Which reminds me: where's the table of contents?

Ah. Here it is:

## Table of Contents

1. [Preface: Who is this book for?](https://www.freecodecamp.org/news/learn-to-code-book/#preface-who-is-this-book-for)
2. [500 Word Executive Summary](https://www.freecodecamp.org/news/learn-to-code-book/#500-word-executive-summary)
3. [Chapter 1: How to Build Your Skills](https://www.freecodecamp.org/news/learn-to-code-book/#chapter-1-how-to-build-your-skills)
4. [Chapter 2: How to Build Your Network](https://www.freecodecamp.org/news/learn-to-code-book/#chapter-2-how-to-build-your-network)
5. [Chapter 3: How to Build Your Reputation](https://www.freecodecamp.org/news/learn-to-code-book/#chapter-3-how-to-build-your-reputation)
6. [Chapter 4: How to Get Paid to Code – Freelance Clients and the Job Search](https://www.freecodecamp.org/news/learn-to-code-book/#chapter-4-how-to-get-paid-to-code-freelance-clients-and-the-job-search)
7. [Chapter 5: How to Succeed in Your First Developer Job](https://www.freecodecamp.org/news/learn-to-code-book/#chapter-5-how-to-succeed-in-your-first-developer-job)
8. [Epilogue: You Can Do This](https://www.freecodecamp.org/news/learn-to-code-book/#epilogue-you-can-do-this)

## Preface: Who is This Book For?

This book is for anyone who is considering a career in software development.

If you're looking for a career that's flexible, high-paying, and involves a lot of creative problem solving, software development may be for you.

Of course, each of us approaches our own coding journey with certain resources: **time**, **money**, and **opportunity**.

You may be older, and may have kids or elderly relatives you're taking care of. So you may have less **time**.

You may be younger, and may have had less time to build up any savings, or acquire skills that boost your income. So you may have less **money**.

And you may live far away from the major tech cities like San Francisco, Berlin, Tokyo, or Bengaluru.

You may live with disabilities, physical or mental. Agism, racism, and sexism are real. Immigration status can complicate the job search. So can a criminal record.

So you may have less **opportunity**.

Learning to code and getting a developer job is going to be harder for some people that it will be for others. Everyone approaches this challenge from their own starting point, with whatever resources they happen to have on hand.

But wherever you may be starting out from – in terms of time, money, and opportunity – I'll do my best to give you actionable advice.

In other words: you are in the right place.

#### A Quick Note on Terminology

Whenever I use new terms, I'll do my best to define them.

But there are a few terms I'll be saying all the time.

I'll use the words "programming" and "coding" interchangeably.

I'll use the word "app" as it was intended – as shorthand for any sort of application, regardless of whether it runs on a phone, laptop, game console, or refrigerator. (Sorry, Steve Jobs. iPhone does not have a monopoly on the word app.)

I will also use the words "software engineer" and "software developer" interchangeably.

You may encounter people in tech who take issue with this. As though software engineering is some fancy-pants field with a multi-century legacy, like mechanical engineering or civil engineering. And maybe that will be true for your grandkids. But we are still very much in the early days of software development as a field.

I'll just drop this quote here for you:

> "If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization." – Gerald Weinberg, Programmer, Author, and University Professor

### Can Anyone Learn to Code?

Yes. I believe that any sufficiently motivated person can learn to code. At the end of the day, learning to code is a motivational challenge – not a question of aptitude.

On the savannas of Africa – where early humans lived for thousands of years before spreading to Europe, Asia, and the Americas – were there computers?

Programming skills were never something that was selected for over the millennia. Computers as we know them (desktops, laptops, smartphones) emerged in the 80s, 90s, and 00s.

Yes – I do believe that aptitude and interest play a part. But at the end of the day, anyone who wants to become a professional developer will need to put in time at the keyboard.

A vast majority of people who try to learn to code will get frustrated and give up.

I sure did. I got frustrated and gave up. Several times.

But like other people who eventually succeeded, I kept coming back after a few days, and tried again.

I say all this because I want to acknowledge: learning to code and getting a developer job is hard. And it's even harder for some people than others, due to circumstance.

I'm not going to pretend to have faced true adversity in learning to code. Yes, I was in my 30s, and I had no formal background in programming or computers science. But consider this:

I grew up middle class in the United States – a 4th-generation American from an English-speaking home. I went to university. My father went to university. And his father went to university. (His parents before him were farmers from Sweden.)

I benefitted from a sort of intergenerational privilege. A momentum that some families are able to pick up over time when they are not torn apart by war, famine, or slavery.

So that is my giant caveat to you: I am not some motivational figure to pump you up to overcome adversity.

There are a ton of people in the developer community who have overcome real adversity. And I'll reference those people later in the book if you want to seek out their teachings.

I'm not seeking to elevate the field of software development. I'm not going to paint pictures of science fiction utopias that can come about if you learn to code.

Instead, I'm just going to give you practical tips for how you can acquire these skills. And how you can go get a good job, so you can provide for your family.

There's nothing wrong with learning to code because you want a good, stable job.

There's nothing wrong with learning to code so you can start a business.

You may encounter people who say that you must be so passionate about coding that you dream about it. That you clock out of your full-time job, then spend all weekend contributing to open source projects.

I do know people who are *that* passionate about coding. But I also know plenty of people who, after finishing a hard week's work, just want to go spend time in nature, or play board games with friends.

People generally enjoy doing things they're good at doing. And you can develop a reasonable level of passion for coding just by getting better at coding.

So in short: who is this book for? Anyone who wants to get better at coding, and get a job as a developer. That's it.

You don't need to be a self-proclaimed "geek", an introvert, or an ideologically-driven activist. Or any of those stereotypes.

It's fine if you are. But you don't need to be.

So if that's you – if you're serious about learning to code well enough to get paid to code – this book is for you.

And you should start by reading this quick summary of the book. And then reading the rest of it.

## 500 Word Executive Summary

Learning to code is hard. Getting a job as a software developer is even harder. But for many people, it's worth the effort.

Coding is a high-paying, intellectually challenging, creatively rewarding field. There is a clear career progression ahead of you: senior developer, tech lead, engineering manager, CTO, and perhaps even CEO.

You can find work in just about any industry. About two thirds of developer jobs are outside of what we traditionally call "tech" – in agriculture, manufacturing, government, and service industries like banking and healthcare.

If you're worried your job might be automated before you reach retirement, consider this: coding is the act of automating things. Thus it is by definition the last career that will be completely automated.

Have I sold you on coding as a good career for you? Then here's what you need to do to break into the field.

### Build your skills.

You need to learn:

- Front End Development: HTML, CSS, JavaScript
- Back End Development: SQL, Git, Linux, and Webservers
- Scientific Computing: Python and its many libraries

These are all mature, 20+ year old technologies. Whichever company you work for, you will almost certainly use most of these tools.

The best way to learn these tools is to build projects. Try to code at least some every day. If you do the freeCodeCamp curriculum from top to bottom, you'll learn all of this and build dozens of projects.

![Learn_to_Code_-_For_Free_-_Coding_Courses_for_Busy_People_--](https://www.freecodecamp.org/news/content/images/2023/01/Learn_to_Code_-_For_Free_-_Coding_Courses_for_Busy_People_--.png)Some of the certifications in the freeCodeCamp core curriculum.

### Build your network.

So much of getting a job is who you know.

It's OK to be an introvert, but you do need to push your boundaries.

Create GitHub, Twitter, LinkedIn, and Discord accounts.

Go to tech meetups and conferences. Travel if you have to. (Most of your "learn to code" budget should go toward travel and event tickets – not books and courses.)

Greet people who are standing by themselves. Let others do most of the talking, and really listen. Remember people's names.

Add people on LinkedIn, follow them on Twitter, and go to after-parties.

### Build your reputation.

Share short video demos of your projects.

Keep applying to speak at bigger and bigger conferences.

Hang out at hackerspaces and help people who are even newer to coding than you.

Contribute to open source. The work is similar to professional software development.

**Build all 3 of these at the same time.** Don't let yourself procrastinate the scariest parts.

Instead of applying for jobs through the "front door", use your network to land job interviews through the "side door". Recruiters can help, too.

Keep interviewing until you start getting job offers. You don't need to accept the first offer you get, though. Be patient.

Your first developer job will be the hardest. Try to stay there for at least 2 years, and essentially get paid to learn.

The real learning begins once you're on-the-job, working alongside a team, and with large legacy codebases.

Most importantly, sleep and exercise.

Any sufficiently-motivated person can learn to code well enough to get a job as a developer.

It's just a question of how badly you want it, and how persistent you can be in the job search.

Remember: you can do this.

## This Book is Dedicated to the Global freeCodeCamp Community.

Thank you to all of you who have supported our charity and our mission over the past 8 years.

It is through your volunteerism and through your philanthropy that we've been able to help so many people learn to code and get their first developer job.

The community has grown so much from the humble open source project I first deployed in 2014. I am now just a small part of this global community.

It is a privilege to still be here, working alongside you all. Together, we face the fundamental problems of our time. Access to information. Access to education. And access to the tools that are shaping the future.

These are still early days. I have no illusion that everyone will know how to code within my lifetime. But just like the Gutenberg Bible accelerated literacy in 1455, we can continue to accelerate technology literacy through free, open learning resources.

Again, thank you all.

And special thanks to Abbey Rennemeyer for her editorial feedback, and to Estefania Cassingena Navone for designing the book cover.

And now, the book.

## Chapter 1: How to Build Your Skills

> "Every artist was first an amateur." ― Ralph Waldo Emerson

The road to knowing how to code is a long one.

For me, it was an ambiguous one.

But it doesn't have to be like that for you.

In this chapter, I'm going to share some strategies for learning to code as smoothly as possible.

First, allow me to walk you through how I learned to code back in 2011.

Then I'll share what I learned from this process.

I'll show you how to learn much more efficiently than I did.

### Story Time: How Did a Teacher in His 30s Teach Himself to Code?

I was a teacher running an English school. We had about 100 adult-aged students who had traveled to California from all around the world. They were learning advanced English so they could get into grad school.

Most of our school's teachers loved teaching. They loved hanging out with students around town, and helping them improve their conversational English.

What these teachers didn't love was paperwork: Attendance reports. Grade reports. Immigration paperwork.

I wanted our teachers to be able to spend more time with students. And less time chained to their desks doing paperwork.

But what did I know about computers?

Programming? Didn't you have to be smart to do that? I could barely configure a WiFi router. And I sucked at math.

Well one day I just pushed all that aside and thought "You know what: I'm going to give it a try. What do I have to lose?"

I started googling questions like "how to automatically click through websites." And "how to import data from websites into Excel."

I didn't realize it at the time, but I was learning how to automate workflows.

And the learning began. First with Excel macros. Then with a tool called AutoHotKey where you can program your mouse to move to certain coordinates of a screen, click around, copy text, then move to different coordinates and paste it.

After a few weeks of grasping in the dark, I figured out how to automate a few tasks. I could open an Excel spreadsheet and a website, run my script, then come back 10 minutes later and the spreadsheet would be fully populated.

It was the work of an amateur. What developers might call a "dirty hack". But it got the job done.

I used my newfound automation skills to continue streamlining the school.

Soon teachers barely had to touch a computer. I was doing the work of several teachers, just with my rudimentary skills.

This had a visible impact on the school. So much of our time had been tied up with rote work on the computer. And now we were free.

The teachers were happier. They spent more time with students.

The students were happier. They told all their friends back in their home country "you've got to check out this school."

Soon we were one of the most successful schools in the entire school system.

This further emboldened me. I remember thinking to myself: "Maybe I **can** learn to code."

I knew some software engineers from my board game night. They had traditional backgrounds, with degrees from Cal Tech, Harvey Mudd, and other famous Computer Science programs.

At the time, it was far less common for people in their 30s to learn to code.

I worked up the courage to share my dreams with some of these friends.

I wanted to learn to how program properly. I wanted to be able to write code for a living like they did. And to maybe even write software that could power schools.

I would share these dreams up with my developer friends. "I want to do what you do."

But they would sort of shrug. Then they'd say something like:

"I mean, you could try. But you're going to have to drink an entire ocean of knowledge."

And: "It's a pretty competitive field. How are you going to hang with people who grew up coding from an early age?"

And: "You're already doing fine as a teacher. Why don't you just stick with what you're good at?"

And that would knock me off course for a few weeks. I would go on long, soul-searching walks at night. I would ponder my future under the stars. Were these people right? I mean – they would know, right?

But every morning I'd be back at my desk. Watching my scripts run. Watching my reports compile themselves at superhuman speeds. Watching as my computer did my bidding.

A thought did occur to me: maybe these friends were just trying to save me from heartache. Maybe they just don't know anyone who learned to code in their 30s. So they don't think it's possible.

It's like... for years doctors thought that it would be impossible for someone to run a mile in 4 minutes. They thought your heart would explode from running so fast.

But then somebody managed to do it. And his heart did not explode.

Once Roger Bannister – a 25-year old Oxford student – broke that psychological barrier – a ton of other people did it, too. To date, more than 1,000 people have run a sub-4 minute mile.

![Roger-Bannister-1951_jpg__1269-1600_](https://www.freecodecamp.org/news/content/images/2023/01/Roger-Bannister-1951_jpg__1269-1600_.png)Roger Bannister running like a a champ. (Image: Britannica)

And it's not like I was doing something bold and unprecedented as running a 4 minute mile here. Plenty of famous developers have managed to teach themselves coding over the years.

Heck, Ada Lovelace taught herself programming in the 1840s. And she didn't even have a working computer. She just had an understanding of how her friend Charles Babbage's computer would work in theory.

She wrote several of the first computer algorithms. And she's widely regarded as the world's first computer programmer. Nobody taught her. Because there was nobody to teach her. Whatever self doubt she may have had, she clearly overcame it.

I was no Ada Lovelace. I was just some teacher who already had a working computer, a decent internet connection, and the ability to search through billions of webpages with Google.

I cracked my knuckles and narrowed my gaze. I was going to do this.

### Stuck in Tutorial Hell

> "If you work for 10 years, do you get 10 years of experience or do you get 1 year of experience 10 times? You have to reflect on your activities to get true experience. If you make learning a continuous commitment, you’ll get experience. If you don’t, you won’t, no matter how many years you have under your belt." – Steve McConnell, Software Engineer

I spent the next few weeks googling around, and doing random tutorials that I encountered online.

Oh look, a Ruby tutorial.

Uh-oh, it's starting to get hard. I'm getting error messages not mentioned in the tutorial. Hm... what's going on here...

Oh look, a Python tutorial.

Human psychology is a funny thing. The moment something starts to get hard, we ask: am I doing this right?

Maybe this tutorial is out of date. Maybe its author didn't know what they were talking about. Does anybody even still use this programming language?

When you're facing the ambiguous error messages hours into a coding session, the grass on the other side starts to look a lot greener.

It was easy to pretend I'd made progress. Time to go grab lunch.

I'd see a friend at the café. "How's your coding going?" they'd ask.

"It's going great. I already coded 4 hours today."

"Awesome. I'd love to see what you're building sometime."

"Sure thing," I'd say, knowing that I'd built nothing. "Soon."

Maybe I'd go to the book store and get a new JavaScript book.

Buying books is the best feeling in the world. Because it also feels like you're buying the time to read them.

And this is precisely where I found myself a few weeks into learning to code.

I had read the first 100 pages of several programming books, but finished none.

I had written the first 100 lines of code from several programming tutorials, but finished none.

I didn't know it, but I was trapped in place that developers lovingly call "tutorial hell."

Tutorial hell is where you jump from one tutorial to the next, learning and then relearning the same basic things. But never really going beyond the fundamentals.

Because going beyond the fundamentals – that requires some real work.

### It Takes a Village to Raise a Coder

Learning to code was absorbing all of my free time. But I wasn't making much progress. I could now type the `{` and `*` characters without looking at the keyboard. But that was about it.

I knew I needed help. Perhaps some Yoda-like mentor, who could teach me the ways. Yes – if such a person existed, surely that would make all the difference.

I found out about a nearby place called a "hackerspace." When I first heard the name, I was a bit apprehensive. Don't hackers do illegal things? I was an English teacher who liked playing board games. I was not looking for trouble.

Well I called the number listed and talked with a guy named Steve. I nervously asked: "You all don't do anything illegal, do you?" And Steve laughed.

It turns out the word "hack" is what he called an overloaded term. Yes – "to hack" can mean to maliciously break into a software system. But "to hack" can also mean something more mundane: to write computer code.

Something can be "hacky" meaning it's not an elegant solution. And yet you can have "a clever hack" – an ingenious trick to make your code work more efficiently.

In short: don't be scared of the term "hack."

![1200x-1_jpg__1200-797_](https://www.freecodecamp.org/news/content/images/2023/01/1200x-1_jpg__1200-797_.png)Facebook's corporate campus has the word "hack" written in giant letter on the concrete. (Image: Bloomberg)

I, for one, scarcely use the term because it's so confusing. And I think recently a lot of hackerspaces have picked up on the ambiguity. Many of them now call themselves "makerspaces" instead.

Because that's what a hackerspace is all about – making things.

Steve invited me to visit the hackerspace on Saturday afternoon. He said several developers from the area would be there.

The first time I walked through the doors of the Santa Barbara Hackerspace, I was blown away.

The place smelled like an electric fire. Its makeshift tables were lined with soldering irons, strips of LED lights, hobbyist Arduino circuit boards, and piles of Roomba vacuum robots.

The same Steve I'd spoken to on the phone was there, and he greeted me. He had glasses, slicked back hair, and a goatee beard. He was always smiling. And when you asked him a question, instead of responding quickly, he would nod and think for a few seconds first.

Steve was a passionate programmer who had studied math and philosophy at the University of California – Santa Barbara. He was still passionate about those subjects. But his real passion was Python.

Steve turned on the projector and gave an informal "lightning talk." He was demoing an app he'd written that would recognize QR codes in a video and replace them with images.

Someone in the audience pulled up a QR code on their laptop and held it in front of the camera. Steve's app then replaced the QR code with a picture of a pizza.

Somebody in the audience shouted, "Can you make the pizza spin?"

Steve opened up his code in a code editor called Emacs, and started making changes to it in real time. He effortlessly tabbed between his code editor, his command line, and the browser the app was running in, "hot loading" updates to the code.

For me, this was sorcery. I couldn't believe Steve had just busted out that app over the course of few hours. And now he was adding new features on the fly, as the audience requested them.

I thought: "This guy is a genius."

And that evening, after the event ended, he and I stayed after and I told him so.

We ate sandwiches together. And I said to him: "I could code for my entire career and not be as good as you. I would be thrilled if after 10 years I could code even half as well as you."

But Steve pushed back. He said, "I'm nothing special. Don't limit yourself. If you stick with coding, you could easily surpass me."

I didn't for a second believe the words he said to me. But just the fact that he said it gave me butterflies.

Here he was: a developer who believed in me. He saw me – some random teacher – the very definition of a "script kiddie" – and thought I could make it.

Steve and I talked late into the night. He showed me his $200 netbook computer, which even by 2011 standards was woefully underpowered.

"You don't need a powerful computer to build software," Steve told me. "Today's hardware is incredibly powerful. Computers are only slow because the bloated software they run makes them slow. Get an off-the-shelf laptop, wipe the hard drive, install Linux on it, and start coding."

I took note of the model of laptop he had and ordered the exact same one when I got home that night.

After a few days of debugging my new computer with Stack Overflow, I successfully installed Ubuntu. I started learning how to use the Emacs code editor. By the following Saturday, I knew a few commands, and was quick to show them off.

Steve nodded in approval. He said, "Awesome. But what are you building?"

I didn't understand what he meant. "I'm learning how to use Emacs. Check it out. I memorized..."

But Steve looked pensive. "That's cool and all. But you need a project. Always have a project. Then learn what you need to learn en route to finishing that project."

我除了帮助学校的老师写的几个脚本之外，我从来没有完成过任何东西。但我开始明白他所说的是什么意思。

这一刻我恍然大悟了。一直以来，我都被困在教程的地狱里，兜兜转转，什么也没完成。

史蒂夫说："我希望你用HTML5建立一个项目。下周六，我希望你在黑客空间（hackerspace）展示它。"

听到他的话，我感到很羞愧。但我站直了身子，对他说： "这个计划听起来不错。我这就开始做。"

### 除了你，没有人可以让你成为一个开发者

> "我试着解放你的心灵，尼奥。 但我只能带你到门口，你必须自己走过去。" （莫斐斯，1999年电影《黑客帝国》） 

第二天早上，我在上班前起得特别早，在网上搜索 "HTML5教程 "之类的东西。在之前的教程地狱中，我已经了解了很多相关知识。我没有跳过，而是放慢脚步，准确地跟着教程走，输入每一条命令。

通常情况下，一旦我完成一个教程，我就会去找另一个教程。但是，我却开始玩起了教程中的代码。我对自己想做的项目有了初步的想法，我打算制作一个纯HTML5的文档页面。

\---

如果你不知道什么是HTML5，让我快速地解释一下。它只是HTML的一个较新的版本，从20世纪90年代的第一个网页开始，它就已经存在了。

如果一个网站是一个身体，那么HTML就是骨头。其他一切都建立在这些骨骼之上。(你可以把JavaScript看作是肌肉，把CSS看作是皮肤）。

让我们重新回到故事上来。

\---

我已经知道在HTML中，你可以通过使用ID属性链接到同一个网页的不同部分。所以我想：如果我沿着左手边放一个目录会怎么样？点击左边的不同选项（item），右边的页面就会相应地滚动并显示这些项目。

半个小时内，我就编出了一个粗略的原型。

但是又到了去学校报到的时间了，我只好中断编程。整整一天，我所想的都是我的项目，以及我应该如何最好地完成它。 

我飞快地跑回家，打开我的笔记本电脑，花了整整一个晚上来编码。

我把官方和使用创作共用许可证 （Creative Commons license）的HTML文档直接复制到我的页面，把它 "硬编码 "到HTML中。

然后，我花了大约一个小时的时间在CSS上，让所有东西看起来都是正确的，并使用绝对定位来保持侧边栏的位置。

我尽可能多地使用了HTML5的新 "语义 "标签。

轰--项目完成了。 

一股成就感涌上心头。我慢跑到附近的一个足球场，绕着球场跑了几圈，庆祝一下。我成功了，我完成了一个项目。 

我当时就决定：从现在开始，我所做的一切都将成为一个项目。我将努力使它成为一个完成品。

第二天晚上，我走到讲台上，插上我的笔记本电脑，展示了我的HTML5网页。我回答了在场的开发者们关于HTML5的问题。

有时我会弄错一些东西，这时我会听到听众说，"这听起来不对--让我查查文档"。

人们并不害怕纠正我。但他们都很有礼貌，而且乐于提供支持。我甚至不觉得他们在纠正我，感觉他们比较像是在纠正公共记录，以免有人带着错误的信息离开。

我没有感到任何可能在在职教师会议上发表演讲的焦虑。

相反地，我几乎觉得自己是观众的一部分，与他们一起学习。

毕竟，这些都是新兴的开发工具。我们都在努力了解如何使用它们。 

我的演讲结束后，史蒂夫走过来对我说："还不错"。

我尴尬地笑了很久，没有说什么，只是对自己很满意。

然后史蒂夫眯着眼睛，抿起嘴。他说： "今晚开始你的下一个项目"。


### 我的编码之旅的经验教训

我们会在接下来的每一章中查看小昆西的编码之旅。但现在我想把这里的一些教训分解一下。我还想回答你可能有的一些问题。


### 为什么学习编码如此困难？

学习任何新技能都是困难的。无论是运球，还是给汽车换油，或是说一门新的语言。

有几个特别的原因让学习代码如此困难，而其中一些是编码所特有的。

第一个原因是，大多数人不明白编码到底是什么。那么，我这就来告诉你。


### 什么是编码？

编码是用计算机能理解的方式告诉计算机要做什么。

所谓的编码就仅仅是这样而已。 

但你不要搞错了，与计算机沟通是很难的。按照人类的标准，它们很 "愚蠢"。它们会完全按照你的要求去做，但除非你擅长编码，否则它们可能不会做你“想”让它们做的事。 

你可能在想：那服务器呢？数据库呢？网络呢？

归根结底，这些都是由一层层的软件控制的，而这些软件都是由代码所组成。从最上层

一路往下都是代码所构成的，直到抵达最底层的物理硬件，也就是在电路板上移动的电子。

在计算机发展最初的几十年里，开发人员编写的代码是 "接近金属 "的，意思是他们通常是直接在硬件上操作，将比特从0翻转到1，再翻转回来。

但是，当代的软件开发涉及许多 "抽象层"——一个程序运行在另外的程序之上，仅仅几行JavaScript代码就可以完成一些非常强大的事情。

在20世纪60年代，一个 "bug" （虫子，也有程序错误的意思）可能是一只昆虫在一个房间大小的计算机中爬来爬去，并在其中一个电路中被烧毁。

![First_Computer_Bug-_1945](https://www.freecodecamp.org/news/content/images/2023/01/First_Computer_Bug-_1945.jpeg)

 1945 年发现的史上第一个计算机虫子是一只飞蛾，它被困在哈佛大学一个房间大小的计算机的面板中。  (图片：Public Domain)

今天，我们编写的代码比物理硬件高出了许多抽象层。

这就是编码。它比过去要容易得多。而且它每年都在变得更加容易。

不夸张地说，几十年后，编码将变得如此简单和普遍，以至于大多数年轻人都会知道如何编码。


## 为什么即使在2023年，学习编码仍然很难？

 即使在2023年，学习编码也是如此困难，有三大原因。

1. 工具仍然很原始

2. 大多数人不善于处理模棱两可的问题，而学习编码面对的就是这样的问题。人们常会迷失方向。

3. 大多数人不善于处理持续的负面反馈，而学习编码常常会收到一个又一个残酷的错误信息，会使人感到沮丧。

现在我将更详细地一一讨论这些困难。我还会教你一些实用的策略来克服每一项困难。


### 工具仍然是原始的

![tng-s4e19-171](https://www.freecodecamp.org/news/content/images/2023/01/TNG-S4E19-171.jpeg)

 来自《星际迷航：下一代》着魔似的巴克利（Barclay）在全息甲板（Holodeck）上编程

>   "计算机，开始新的程序，创建如下：工作站的椅子，现在创建一个标准的字母数字控制台，定位在左手；现在为右手创建一个标志性的显示控制台。将这两个控制台与企业主计算机核心相连，利用神经扫描界面。" ——巴克利，来自《星际迷航：下一代》第四季第19集："第N度"

上面我拿了我最喜欢的科幻电视剧《星际迷航：下一代》中的一段作为例子，告诉你这就是人们在未来可能的编程方式。

《星际迷航》中的每个角色都会编码。医生、保安人员、飞行员，甚至小韦斯利-克鲁舍（Wesley Crusher，由儿童演员威尔-惠顿扮演）也能让飞船上的计算机听从他的命令。

当然，每个人都会编码的原因之一是他们生活在一个后稀缺的24世纪社会，可以获得免费的高质量教育。

另一个原因是，在未来，编码会容易得多。你只需准确地告诉计算机要做什么，然后，如果你足够精确，计算机就会执行。 

如果编程就像用简单的英语对计算机说指令一样容易呢？

我们已经朝着这个目标取得了重大进展。想一想以前我们的祖母，她们在房间大小的大型计算机和成堆的打孔卡（punch cards）之间奔波。 

![naca-computer-operates-an-ibm-telereader-5b6f9f-1024](https://www.freecodecamp.org/news/content/images/2023/01/naca-computer-operates-an-ibm-telereader-5b6f9f-1024.jpeg)
20世纪50年代使用打卡机的计算机（图片：NASA）

过去，即使是一个简单的应用程序的编程也需要严谨的指令。

这里有两个 "凯撒密码 "（Cesar Cypher）的例子，这是经典的计算机科学家庭作业项目。

这也被称为 "ROT-13"，因为你将字母ROT了13个位置。例如，A变成N（A后13个字母），B变成O（B后13个字母）。 

我将向你展示这个程序的两个例子，这两个例子都来自创作共用许可证的罗塞塔代码（Rosetta Code）项目。 

首先，这是x86汇编中的程序：

```x86
format 	ELF 	executable 3
entry 	start
	
segment	readable writeable
buf	rb	1
	
segment	readable executable
start:	mov	eax, 3		; syscall "read"
	mov	ebx, 0		; stdin
	mov	ecx, buf	; buffer for read byte
	mov	edx, 1		; len (read one byte)
	int	80h

	cmp	eax, 0		; EOF?
	jz	exit

	xor 	eax, eax	; load read char to eax
	mov	al, [buf]
	cmp	eax, "A"	; see if it is in ascii a-z or A-Z
	jl	print
	cmp	eax, "z"
	jg	print
	cmp	eax, "Z"
	jle	rotup
	cmp	eax, "a"
	jge	rotlow
	jmp	print

rotup:	sub	eax, "A"-13	; do rot 13 for A-Z
	cdq
	mov	ebx, 26
	div	ebx
	add	edx, "A"
	jmp	rotend
	
rotlow:	sub	eax, "a"-13	; do rot 13 for a-z
	cdq
	mov	ebx, 26
	div	ebx
	add	edx, "a"

rotend:	mov	[buf], dl
	
print: 	mov	eax, 4		; syscall write
	mov	ebx, 1		; stdout
	mov	ecx, buf	; *char
	mov	edx, 1		; string length
	int	80h

	jmp	start

exit: 	mov     eax,1		; syscall exit
	xor     ebx,ebx		; exit code
	int     80h
```

下面是Python中的同一程序:

```python
import string

TRANSLATION_TABLE = str.maketrans(
    string.ascii_uppercase + string.ascii_lowercase,
    string.ascii_uppercase[13:] + string.ascii_uppercase[:13] +
    string.ascii_lowercase[13:] + string.ascii_lowercase[:13]
)


def rot13(s):
    """Return the rot-13 encoding of s."""
    return s.translate(TRANSLATION_TABLE)


if __name__ == "__main__":
    """rot-13 encode the input files, or stdin if no files are provided."""
    import fileinput
    for line in fileinput.input():
        print(rot13(line), end="")
```

更简单，更容易阅读，对吗？

 而在未来，编码将像对你的宇宙飞船说的那样简单。

"计算机，开始新程序。把我说的每一个字母，替换成英语字母表中13个位置之后出现的字母，然后将结果读回给我。这个词就是 "香蕉"。

然后你的电脑会说： "Onanan"。

我们正在做的事情被称为 "声明式编程" （declarative programming）。我们在宣布 "计算机，你应该这样做"。而计算机足够聪明（编程足够好），能够理解我们的指令并执行它们。

Here in 2023, the style of coding most of us are doing is "imperative programming." We're telling the computer exactly what to do, step-by-step.

Computers are dumb, so we have to help them put one foot in front of the other.

Right now, the field just isn't mature yet.

Early human tools advanced from stone to bronze to iron. And the same thing is happening with software tools. But much faster.

We're probably in the programming equivalent of the bronze age right now. But we may reach the iron age in our lifetime.

### Learning to Code is an Ambiguous Process

When you're learning to code, you constantly ask yourself: "Am I spending my time wisely? Am I learning the right tools? Do these book authors / course creators even know what they're talking about?"

Ambiguity fogs your every study session. "Did my test case fail because the tutorial is out of date, and there have been breaking changes to the framework I'm using? Or am I just doing it wrong?"

As I mentioned earlier with Tutorial Hell, you also have to cope with "grass is greener on the other side" disease.

This is compounded by the fact that some developers think it's clever to answer questions with "RTFM" which means "Read the Freaking Manual." Not super helpful. Which manual? Which section?

Another problem is: you don't know what you don't know. Often you can't even articulate the question you're trying to ask.

And if you can't even ask the right question, you're going to thrash.

This is extra hard with coding because it's possible no one has attempted to build quite the same app that you're building.

And thus some of the problems you encounter may be unprecedented. There may be no one to turn to.

15% of the queries people type into Google every day have never ever been searched before. That's bad news if you're the person typing one of those.

My theory is that most developers will figure out how to solve a problem and simply move on, without ever documenting it anywhere. So you may be one of dozens of developers who has had to invent their own solution to the same exact problem.

And then, of course, there are the old forum threads and StackOverflow pages.

![wisdom_of_the_ancients_png__485-270_](https://www.freecodecamp.org/news/content/images/2023/01/wisdom_of_the_ancients_png__485-270_.png)Comic by XKCD

### How Not to Get Lost When Learning to Code

The good news is: both **competence** and **confidence** come with practice.

Soon you'll know exactly what to google. You'll get a second sense for how documentation is usually structured, and where to look for what. And you'll know where to ask which questions.

I wish there were a simpler solution to the ambiguity problem. But you just need to accept it. Learning to code is an ambiguous process. And even experienced developers grapple with ambiguity.

After all, coding is the rare profession where you can just infinitely reuse solutions to problems you've previously encountered.

Thus as a developer, you are always doing something you've never done before.

People think software development is about typing code into a computer. But it's really about learning.

You're going to spend a huge portion of your career just thinking really hard. Or blindly inputting commands into a prompt trying to understand how a system works.

And you're going to spend a lot of time in meetings with other people: managers, customers, fellow devs. Learning about the problem that needs to be solved, so you can build a solution to it.

Get comfortable with ambiguity and you will go far.

### Learning to Code is One Error Message After Another

A lot of people who are learning to code feel like they hit a wall. Progress does not come as fast as they expect.

One huge reason for this: in programming, the feedback loop is much tighter than in other fields.

In most schools, your teacher will give you assignments, then grade those assignments and give them back to you. Over the course of a semester, you may only have a dozen instances where you get feedback.

"Oh no, I really bombed that exam," you might say to yourself. "I need to study harder for the midterm."

Maybe your teacher will leave notes in red ink on your paper to help you improve your work.

Getting a bad grade on an exam or paper can really ruin your day.

And that's how we generally think about feedback as humans.

If you've spent much time coding, you know that computers are quite fast. They can execute your code within a few milliseconds.

Most of the time your code will crash.

If you're lucky, you'll get an error message.

And if you're really lucky, you'll get a "stack trace" – everything the computer was trying to do when it encountered the error – along with the line of code that caused the program to crash.

![A stack trace error message while running freeCodeCamp locally.](https://www.freecodecamp.org/news/content/images/2023/01/oh-my-zsh-stack-trace-error.jpg)

Now this in-your-face negative feedback from a computer. Not everyone can handle it seeing this over and over all day long.

Imagine if every time you handed your teacher your term paper, they handed it back with big red "F" written on it. And imagine they did this before you could even blink. Over and over.

That's what coding can feel like sometimes. You want to grab the computer and shout at it, "why don't you just understand what I'm trying to do?"

### How Not to Get Frustrated

The key, again, is practice.

Over time, you will develop a tolerance for vague error messages and screen-length stack traces.

Coding will never be harder than it is when you're just starting out.

Not only do you not know what you're doing, but you're not used to receiving such impersonal, rapid-fire, negative feedback.

So here are some tips:

#### Tip #1: Know that you are not uniquely bad at this.

Everyone who learns to code struggles with the frustration of trying to Vulcan Mind Meld with a computer, and get it to understand you. (That's another Star Trek reference.)

Of course, some people started programming when they were just kids. They may act like they've always been good at programming. But they most likely struggled just like we adults do, and over time have simply forgotten the hours of frustration.

Think of the computer as your friend, not your adversary. It's just asking you to clarify your instructions.

#### Tip #2: Breathe.

Many people's natural reaction when they get an error message is to gnash their teeth. Then go back into their code editor and start blindly changing code, hoping to somehow luck into getting past it.

This does not work. And I'll tell you why.

The universe is complex. Software is complex. You are unlikely to just Forest Gump your way into anything good.

![gump](https://www.freecodecamp.org/news/content/images/2023/01/gump.jpeg)Forest Gump doing what he does and getting improbably lucky catching shrimp.

You may have heard of the Infinite Monkey Theorem. It's a thought experiment where you imagine chimpanzees typing on typewriters.

If you had a newsroom full of chimpanzees doing this, how long would it take before one of them typed out the phrase "to be or not to be" by random chance?

Let's say each chimp types one random character per second. It would likely take 1 quintillion years for one of them to type "to be or not to be." That's 10 to the 18th power. A billion billion.

Even assuming the chimps remain in good health and the typewriters are regularly serviced – the galaxy would be a cold, dark void by the time one of them managed to type "to be or not to be."

Why do I tell you all of this? Because you don't want to be one of those chimps.

In that time, you could almost certainly figure out a way to teach those chimps how to type English words. They could probably manage to type out all of Hamlet – not just its most famous line.

Even if you somehow do get lucky, and get past the bug, what will you have learned?

So instead of thrashing, you want to take some time. Understand the code. Understand what's happing. And then fix the error.

Always take time to understand the failing code. Don't be a quintillionarian chimp. (I think that means someone who is 1 quintillion years old, though according to Google, nobody has ever typed that word before.)

Instead of blindly trying things, hoping to get past the error message, slow down.

Take a deep breath. Stretch. Get up to grab a hot beverage.

Your future self will be grateful that you took this as a teachable moment.

#### Tip #3: Use Rubber Duck Debugging

Get a rubber ducky and set it next to your computer. Every time you hit an error message, try to explain what you think is happening to your rubber duck.

Of course, this is silly. How could this possibly be helpful?

Except it is.

Rubber Duck Debugging is a great tool for slowing down and talking through the problem at hand.

You don't have to use a rubber duck, of course. You could explain your Python app to your pet cactus. Your SQL query to the cat that keeps jumping onto your keyboard.

The very act of explaining your thinking out loud seems to help you process the situation better.

### How do Most People Learn to Code?

Now let's talk about traditional pathways to a first developer job.

Why should you care what everyone else does? Spoiler alert: you don't really need to.

You do **you**.

This said, you may doubt yourself and the decisions you've made about your learning. You may yearn for the path not taken.

My goal with this section is to calm any anxieties you may have.

#### The Importance of Computer Science Degrees

University degrees are still the gold standard for preparing for a career in software development. Especially bachelor's degrees in Computer Science.

Before you start saying "But I don't have a computer science degree" – no worries. **You don't need a Computer Science degree to become a developer**.

But their usefulness is undeniable. And I'll explain why.

First, you may wonder: why should developers study computer science? After all, one of the most prominent developers of all time had this to say about the field:

> "Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter." – Eric Raymond, Developer, Computer Scientist, and Author

Computer Science departments were traditionally part of the math department. Universities back in the 1960s and 1970s didn't know quite where to put this whole computer thing.

At other universities, Computer Science was considered an extension of Electrical Engineering. And until recently, even University of California – Berkeley – one of the greatest public universities in the world – only provided Computer Science degrees as sort of a double-major with Electrical Engineering.

But most universities have now come to understand the importance of Computer Science as a field of study.

As of writing this, Computer Science is the highest paying degree you can get. Higher even than fields focused on money, such as Finance and Economics.

[According to Glassdoor](https://www.glassdoor.com/blog/50-highest-paying-college-majors/), the average US-based Computer Science major makes more money at their first job than any other major. US $70,000. That's a lot of money for someone who just graduated from college.

More than Nursing majors ($59,000), Finance majors ($55,000) and Architecture majors ($50,000).

OK – so getting a Computer Science degree can help you land a high-paying entry level job. That is probably news to no one. But why is that?

#### How Employers Think About Bachelor's Degrees

You may have heard some big employers in tech say things like, "we no longer require job candidates to have a bachelor's degree."

Google said this. Apple said this.

And I believe them. That they no longer require bachelor's degrees.

We've had lots of freeCodeCamp alumni get jobs at these companies, some of whom did not have a bachelor's degrees.

But those freeCodeCamp alumni who landed those jobs probably had to be extra strong candidates to overcome the fact that they didn't have bachelor's degrees.

You can look at these job openings as having a variety of criteria they judge candidates on:

1. Work experience
2. Education
3. Portfolio and projects
4. Do they have a recommendation from someone who already works at the company? (We'll discuss building your network in depth in Chapter 2)
5. Other reputation considerations (we'll discuss building your reputation in Chapter 3)

For these employers who do not require a bachelor's degree, education is just one of several considerations. If you are stronger in other areas, they may opt to interview you – regardless of whether you've ever even set foot inside a university classroom.

Just note that having a bachelor's degree will make it easier for you to get an interview, even at these "degree-optional" employers.

#### Why do so Many Developer Jobs Require a Computer Science Degree Specifically?

A bachelor's is a bachelor's, I often tell people. Because for most intents and purposes, it is.

Want to enter the US military as an officer, rather than an enlisted service member? You'll need a bachelor's degree, but any major will do.

Want to get a work visa to work abroad? You'll probably need a bachelor's degree, but any major will do.

And for so many job openings that say "bachelor's degree required" – any major will do.

Why is this? Doesn't the subject you study in university matter at all?

Well, here's my theory on this: what you learn in university is less important than **whether** you finished university.

Employers are trying to select for people who can figure out a way to get through this rite of passage.

It is certainly true that you can be at the bottom of your class, repeating courses you failed, and being on academic probation for half the time. But a degree is a degree.

You know what they call the student who finished last in their class at medical school? "Doctor."

And for most employers, the same holds true.

In many cases, HR folks are just checking a box on their job application filtering software. They're filtering out applicants who don't have a degree. In those cases, they may never even look at job applications from people without degrees.

Again, not every employer is like this. But many of them are. Here in the US, and perhaps even more so in other countries.

It sucks, but it's how the labor market works right now. It may change over the next few decades. It may not.

This is why I always encourage people who are in their teens and 20s to seriously considering getting a bachelor's degree.

Not because of any of the things universities market themselves as:

- The education itself. (You can take courses from some of the best universities online for free, so this alone does not justify the high cost of tuition.)
- The "college experience" of living in a dorm, making new friends, and self discovery. (Most US University students never live on campus so they don't really get this anyway.)
- General education courses that help you become a "well rounded individual" (Ever hear of the Freshman 15? This is a joke of course. But a lot of university freshman do gain weight due to the stress of the experience.)

Again, the real value of getting a bachelor's degree – the real reason Americans pay $100,000 or more for 4 years of university – is because many employers require degrees.

Of course, there are other benefits of having a bachelor's degree, such as the ones I mentioned: expanded military career options, and greater ease getting work visas.

One of these is: if you want to become a doctor, dentist, lawyer, or professor, you will first need a bachelor's degree. You can then use that to get into grad school.

OK – this is a lot of background information. So allow me to answer your questions bluntly.

### Do You Need a University Degree to Work as a Software Developer?

No. There are plenty of employers who will hire you without a bachelor's degree.

A bachelor's degree will make it much easier to get an interview at a lot of employers. And it may also help you command a higher salary.

### What About Associate's Degrees? Are Those Valuable?

In theory, yes. There are some fields in tech where having an associates may be required. And I think it always does increase your chances of getting an interview.

This said, I would not recommend going to university with the specific goal of getting an associate's degree. I would 100% encourage you to stay in school until you get a bachelor's degree, which is vastly more useful.

According to the US Department of Education, over the course of your career, having a bachelor's degree will earn you 31% more than merely having an associate's degree.

And I'm confident that difference is much wider with a bachelor's in Computer Science.

### Is it Worth Going to University to Get a Bachelor's Degree Later in Life, if You Don't Already Have One?

Let's say you're in your 30s. Maybe you attended some college or university courses. Maybe you completed the first two years and were able to get an associate's degree.

Does it make sense to go "back to school" in the formal sense?

Yes, it may make sense to do so.

But I don't think it ever makes sense to quit your job to go back to school full time.

The full-time student lifestyle is really designed with "traditional" students in mind. That is, people age 18 to 22 (or a bit older if they served in the military), who have not yet entered the workforce beyond high school / summer jobs.

Traditional universities cost a lot of money to attend, and the assumption is that students will pay through some combination of scholarships, family funds, and student loans.

As a working adult, you'll have less access to these funding sources. And just as importantly, you'll have less time on your hands than a recent high school graduate.

But that doesn't mean you have to give up on the dream of getting a bachelor's degree.

Instead of attending a traditional university, I recommend that folks over 30 attend one of the online nonprofit universities. Two that have good reputations, and whose fees are quite reasonable, are Western Governor's University and University of the People.

You may also find a local community college or state university extension program that offers degrees. Many of these programs are online. And some of them are even self-paced, so that you can complete courses as your work schedule permits.

Do your research. If a school looks promising, I recommend finding one of its alumni on LinkedIn and reaching out to them. Ask them questions about their experience, and whether they think it was worth it.

I recommend not taking on any debt to finance your degree. It is much better to attend a cheaper school. After all, a degree is a degree. As long as it's from an accredited institution, it should be fine for most intents and purposes.

### If You Already Have a Bachelor's Degree, Does it Make Sense to Go Back and Earn a Second Bachelor's in Computer Science?

No. Second bachelor's degrees are almost never worth the time and money.

If you have any bachelor's degree – even if it's in a non-STEM field – you have already gotten most of the value you will get out of university.

### What About a Master's of Computer Science Degree?

These can be helpful for career advancement. But you should pursue them later, after you're already working as a developer.

Many employers will pay for their employee's continuing education.

One program a lot of my friends in tech have attended is Georgia Tech's Master's in Computer Science degree.

Georgia Tech's Computer Science department is among the best in the US. And this degree program is not only fully online – it's also quite affordable.

But I wouldn't recommend doing it now. First focus on getting a developer job. (We'll cover that in-depth later in this book).

### Will Degrees Continue to Matter in the Future?

Yes, I believe that university degrees will continue to matter for decades – and possibly centuries – to come.

University degrees have existed for more than 1,000 years.

Many of the top universities in the US are older than the USA itself is. (Harvard is more than 400 years old.)

The death of the university degree is greatly exaggerated.

It has become popular in some circles to bash universities, and say that degrees don't matter anymore.

But if you look at the statistics, this is clearly not true. They do have an impact on lifetime earnings.

And just as importantly, they can open up careers that are safer, more stable, and ultimately more fulfilling.

Sure, you can make excellent money working as a deckhand offshore, servicing oil rigs.

But you can make similarly excellent money working as a developer in a climate-controlled office, servicing servers and patching codebases.

One of these jobs is dangerous, back-breaking work. The other is a job you could comfortably do for 40 years.

Many of the "thought leaders" out there who are bashing universities have themselves benefitted from a university education.

One reason why I think so many people think degrees are "useless" is: it's hard to untangle the learning from the status boost you get.

Is university just a form of class signaling – a way for the wealthy to continue to pass advantage on to their children? After all, you're 20 times as likely to find a rich kid at Harvard as you are a poor kid.

The fact is: life is fundamentally unfair. But that does not change how the labor market works.

You can choose easy mode, and finish a degree that will give you more options down the road.

Or you can go hard mode, potentially save time and money, and just be more selective about which employers you apply to.

I have plenty of friends who've used both approaches to great success.

### What Does a Computer Science Bachelor's Degree Cover?

### What Alternatives are There to a University Degree?

I've worked in adult education for nearly two decades, and I have yet to see a convincing substitute for a university degree.

Sure – there are certification programs and bootcamps.

But these do not carry the same weight with employers. And they are rarely as rigorous.

*Side note: when I say "certification programs" I mean a program where you attend a course, then earn a certification at the end. These are of limited value. But exam-based certifications from companies like Amazon and Microsoft are quite valuable. We'll discuss these in more depth later.*

What I tell people is: to degree or not to degree – that is the question.

I meet lots of people who are auto mechanics, electricians, or who do some other sort of trade, who don't have a bachelor's. They can clearly learn a skillset, apply it, and hold down a job.

I meet lots of people who are bookkeepers, paralegals, and other "knowledge workers" who don't have a bachelor's. They can clearly learn a skillset, apply it, and hold down a job.

In many cases, these people can just learn to code on their own, using free learning resources and hanging out with likeminded people.

Some of these people have always had the personal goal of going back and finishing their bachelor's. That's a good reason to do it.

But it's not for everyone.

If you want formal education, go for the bachelor's degree. If you don't want formal education, don't do any program. Just self-teach.

The main thing bootcamps and other certification programs are going to give you is structure and a little bit of peer pressure. That's not a bad thing. But is it worth paying thousands of dollars for it?

### How to Teach Yourself to Code

Most developers are self-taught. Even the developers who earned a Bachelor's of computer science still often report themselves as "self-taught" on industry surveys like Stack Overflow's annual survey.

![stack-overflow](https://www.freecodecamp.org/news/content/images/2023/01/stack-overflow.jpeg)Most working developers consider themselves to be "self-taught" (Image: Stack Overflow 2016 Survey)

This is because learning to code is a life-long process. There are constantly new tools to learn, new legacy codebases to map out, and new problems to solve.

So whether you pursue formal education or not, know this: you will need to get good at self-teaching.

#### What Does it Mean to be a "Self-Taught" Developer?

Not to be pedantic, but when I refer to self-teaching, I mean self-directed learning – learning outside of formal education.

Very few people are truly "self-taught" at anything. For example, Isaac Newton taught himself Calculus because there were no Calculus books. He had to figure it out and invent it as he went along.

Similarly, Ada Lovelace taught herself programming. Because before her there was no programming. She invented it.

Someone might tell you: "You're not really self taught because you learned from books or online courses. So you had teachers." And they are correct, but only in the most narrow sense.

If someone takes issue with you calling yourself self-taught, just say: "By your standards, no one who wasn't raised by wolves can claim to be self-taught at anything."

Point them to this section of this book and tell them: "Quincy anticipated your snobbery." And then move on with your life.

Because come on, life's too short, right?

You're self taught.

#### What is Self-Directed Learning?

As a self-learner, you are going to curate your own learning resources. You're going to choose what to learn, from where. That is the essence of "Self-Directed Learning."

But how do you know you're learning the right skills, and leveraging the right resources?

Well, that's where community comes in.

There are lots of communities of learners around the world, all helping one another expand their skills.

Community is a hard word to define. Is Tech Twitter a community? What about the freeCodeCamp forum? Or the many Discord groups and subreddits dedicated to specific coding skillsets?

I consider all of these communities. If there are people who regularly hang out there and help one another, I consider it a community.

What about in-person events? The monthly meetup of Ruby developers in Oakland? The New York City Startup community meetup? The Central Texas Linux User Group?

These communities can be online, in-person, or some mix of both.

We'll talk more about communities in the Build Your Network chapter. But the big takeaway is: the new friends you meet in these communities can help you narrow your options for what to learn, and which resources to learn from.

### What Programming Language Should I Learn First?

The short answer is: it doesn't really matter. Once you've learned one programming language well, it is much easier to learn your second language.

There are different types of programming languages, but today most development is done using "high-level scripting languages" like JavaScript and Python. These languages trade away the raw efficiency you get from "low-level programming languages" like C. What they get in return: the benefit of being much easier to use.

Today's computers are billions of times faster than they were in the 1970s and 1980s, when people were writing most of their programs in languages like C. That power more than makes up for the relative inefficiency of scripting languages.

It's worth noting that both JavaScript and Python themselves are written in C, and they are both getting faster every year – thanks to their large communities of open source code contributors.

Python is a powerful language for scientific computing (Data Science and Machine Learning).

And JavaScript... well, JavaScript can do everything. It is the ultimate Swiss Army Knife programming language. JavaScript is the duct tape that holds the World Wide Web together.

> "Any application that can be written in JavaScript, will eventually be written in JavaScript." – Atwood's Law (Jeff Atwood, founder of Stack Overflow and Discourse)

You could code your entire career in JavaScript and would never need to learn a second language. (This said, you'll want to learn Python later on, and maybe some other languages as well.)

So I recommend starting with JavaScript. Not only is it much easier to use than languages like Java and C++ – it's easier to learn, too. And there are far, far more job openings for people who know JavaScript.

![Find_Javascript_Jobs_with_great_pay_and_benefits_in_United_States___Indeed_com_--](https://www.freecodecamp.org/news/content/images/2023/01/Find_Javascript_Jobs_with_great_pay_and_benefits_in_United_States___Indeed_com_--.png)A screenshot from job search engine Indeed. My search for "javascript" for the US yielded 68,838 job listings.

The other skills you'll want to focus on are **HTML** and **CSS**. If a webpage were a body, HTML would be the bones, and CSS would be the skin. (JavaScript would be the muscles, making it possible for the website to move around and be interactive.)

You can learn some HTML and CSS in a single afternoon. Like most of the tools I mention here, they are easy to learn, but difficult to master.

You'll also want to learn how to use **Linux**. Linux powers a vast majority of the world's servers, and you will spend much of your career running commands in the Linux command line.

If you have a Mac, MacOS has a terminal that accepts almost all the same commands as Linux. (MacOS and Linux have a common ancestor in Unix.)

But if you're on a Windows PC, you'll want to install WSL, which stands for Windows Subsystem for Linux. You will then be able to run Linux commands on your PC. And if you're feeling particularly adventurous, you can even dual boot both the Windows and Linux operating systems on the same computer.

If you're going to install Linux on a computer, I recommend starting with Ubuntu. It is the most widely used (and widely documented) Linux distribution. So it should be the most forgiving.

Make no mistake – Linux is quite a bit harder to use than Windows and MacOS. But what you get in return for your efforts is an extremely fast, secure, and highly customizable operating system.

Also, you will never have to pay for an operating system license again. Unless you want to. Red Hat is a billion dollar company even though its software is open source, because companies pay for their help servicing and supporting Linux servers.

You'll also want to learn **Git**. This Version Control System is how teams of developers coordinate their changes to a codebase.

You may have heard of GitHub. It's a website that makes it easier for developers to collaborate on open source projects. And it further extends some of the features of Git. You'll learn more about GitHub in the How to Build Your Reputation chapter later.

You'll want to learn **SQL** and how relational databases work. These are the workhorses of the information economy.

You'll also hear a lot about NoSQL databases (Non-relational databases such as graph databases, document databases, and key-value stores.) You can learn more about these later. But focus on SQL first.

Finally, you'll want to learn how **web servers** work. You'll want to start with Node.js and Express.js.

When you hear the term "full stack development" it refers to tying together the front end (HTML, CSS, JavaScript) with the back end (Linux, SQL databases, and Node + Express).

There are lots of other tools you'll want to learn, like React, NGINX, Docker, and testing libraries. You can pick these up as you go.

But the key skills you should spend 90% of your pre-job learning time on are:

1. HTML
2. CSS
3. JavaScript
4. Linux
5. Git
6. SQL
7. Node.js
8. Express.js

If you learn these tools, you can build most major web and mobile apps. And you will be qualified for most entry-level developer jobs. (Of course, many job descriptions will include other tools, but we'll discuss these later in the book.)

So you may be thinking: great. How do I learn these?

### Where do I learn how to code?

Funny you should ask. There's a full curriculum designed by experienced software engineers and teachers. It's designed with busy adults in mind. And it's completely free and self-paced.

That's right. I'm talking about [freeCodeCamp's core curriculum](https://www.freecodecamp.org/learn). It will help you learn:

- Front End Development
- Back End Development
- Engineering Mathematics
- and Scientific Computing (with Python for Data Science and Machine Learning)

To date, thousands of people have gone through this core curriculum and gotten a developer job. They didn't need to quit their day job, take out loans, or really risk anything other than some of their nights and weekends.

In practice, freeCodeCamp has become the default path for most people who are learning to code on their own.

If nothing else, the freeCodeCamp core curriculum can be your "home base" for learning, and you can branch out from there. You can learn the core skills that most jobs require, and also dabble in technologies you're interested in.

There are decades worth of books and courses to learn from. Some are available at your public library, or through monthly subscription services. (And you may be able to access some of these subscription services for free through your library as well.)

Also, freeCodeCamp now has nearly 1,000 free full-length courses on everything from AWS certification prep to mobile app development to Kali Linux.

There has never been an easier time to teach yourself programming.

### Building Your Skills is a Life-Long Endeavor

We've talked about why self-teaching is probably the best way to go, and how to go about it.

We've talked about the alternatives to self-teaching, such as getting a bachelor's degree in Computer Science, or getting a Master's degree.

And we've talked about which specific tools you should focus on learning first.

Now, let's shift gears and talk about how to build the second leg of your stool: your network.

## Chapter 2: How to Build Your Network

> "If you want to go fast, go alone. If you want to go far, go together." – African Proverb

"Networking." You may wince at the sound of that word.

Networking may bring to mind awkward job fairs in stuffy suits, desperately pushing your résumé into the hands of anyone who will accept it.

Networking may bring to mind alcohol-drenched watch parties – where you pretend to be interested in a sport you don't even follow.

Networking may bring to mind wishing "happy birthday" to people you barely know on LinkedIn, or liking their status updates hoping they'll notice you.

But networking does not have to be that way.

In this chapter, I'll tell you everything I've learned about meeting people. I'll show you how to earn their trust and be top of their mind when they're looking for help.

Because at the end of the day, that's what it's all about. Helping people solve their problems. Being of use to people.

I'll show you how to build a robust personal network that will support you for decades to come.

### Story Time: How did a Teacher in his 30s Build a Network in Tech?

*Last time on Story Time: Quincy learned some coding by reading books, watching free online courses, and hanging out with developers at the local Hackerspace. He had just finished building his first project and given his first tech talk...*

OK – so I now had some rudimentary coding skills. I could now code my way out of the proverbial paper bag.

What was next? After all, I was a total tech outsider.

Well, even though I was new to tech, I wasn't new to working. I'd put food on the table for nearly a decade by working at schools and teaching English.

As a teacher, I got paid to sling knowledge. And as a developer, I'd get paid to sling code.

I already knew one very important truth about the nature of work: it's who you know.

I knew the power of networks. I knew that the path to opportunity goes right through the gatekeepers.

All that stood between me and a lucrative developer job was a hiring manager who could say: "Yes. This Quincy guy seems like someone worthy of joining our team."

Of course, being a tech outsider, I didn't know the culture.

Academic culture is much more formal.

You wear a suit.

You use fancy academic terminology to demonstrate you're part of the "in group."

You find ways to work into every conversation that you went to X university, or that you TA'd under Dr. Y, or that you got published in The Journal of Z.

Career progressions are different. Conferences are different. Power structures are different.

And I didn't immediately appreciate this fact.

The first few tech events I went to, I wore a suit.

I kept neatly-folded copies of my résumé in my pocket at all times.

I even carried business cards. I had ordered sheets of anodized aluminum, and used a laser cutter to etch in my name, email address, and even a quote from legendary educator John Dewey:

> "Anyone who has begun to think places some portion of the world in jeopardy." – John Dewey

It's still my favorite quote to this day.

But talk about heavy-handed.

"Hi, I'm Quincy. Here's my red aluminum business card. Sorry in advance – it might set off the metal detector on your flight home."

I was trying too hard. And it was probably painfully apparent to everyone I talked to.

I went on Meetup.com and RSVP'd for every developer event I could find. Santa Barbara is a small town, but it's near Los Angeles. So I made the drive for events there, too.

I quickly wised up, and traded my suit for jeans and a hoody. And I noticed that no one else gave out business cards. So I stopped carrying them.

I took cues from the devs I met at the hackerspace: Be passionate, but understated. Keep some of your enthusiasm in reserve.

And I read lots of books to better understand developer culture.

[The Coders at Work](https://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/B092R8RQM3?crid=13BTAQ7TH9YSN&linkCode=ll1&tag=out0b4b-20&linkId=32d14a148c54f36f5ef701578a2abd8e&language=en_US&ref_=as_li_ss_tl) is a good book from the 1980s.

[Hackers: Heroes of the Revolution](https://www.amazon.com/Hackers-Computer-Revolution-Steven-Levy/dp/1449388396?&linkCode=ll1&tag=out0b4b-20&linkId=0c216f2cd4cc2d2090b8c9b50b0befee&language=en_US&ref_=as_li_ss_tl) is a good book from the 1990s.

For a more contemporary cultural resource, check out the TV series [Mr. Robot](https://www.amazon.com/Mr-Robot-Complete-Rami-Malek/dp/B0833WXXL6?crid=188UUOE6ZT0W3&keywords=mr+robot&qid=1673746625&sprefix=mr+robot%2Caps%2C111&sr=8-6&linkCode=ll1&tag=out0b4b-20&linkId=a896ab7630fadc332c2696d3a4b8e85d&language=en_US&ref_=as_li_ss_tl). Its characters are a bit extreme, but they do a good job of capturing the mindset and mannerisms of many developers.

Soon, I was talking less like a teacher and more like a developer. I didn't stick out quite as awkwardly.

Several times a week I attended local tech-related events. My favorite event wasn't even a developer event. It was the Santa Barbara Startup Night. Once every few weeks, they'd have an event where developers would pitch their prototypes. Some of the devs demoing their code were even able to secure funding from angels – rich people who invest in early-stage companies.

The guy who ran the event was named Mike. He must have known every developer and entrepreneur in Santa Barbara.

When I finally got the nerve to introduce myself to Mike, I was star-struck. He was an ultra-marathoner with a resting heartbeat in the low 40s. Perfectly cropped hair and beard. To me he was the coolest guy on the planet. Always polished. Always respectful.

Mike was "non-technical." He worked as a product manager. And though he knew a lot about technology and user experience design, he didn't know how to code.

Sometimes devs would write non-technical people off. "He's just a business guy," they'd say. Or: "She's a suit." But I never heard anyone say that about Mike. He had the respect of everyone.

I made a point to watch the way Mike interacted with developers. After all, I wasn't that far removed from "non-technical" myself. I'd only been coding for a few months.

Often my old habits would creep in. During conversations I'd have the temptation to show off what I'd learned or what I'd built.

Many developers are modest about their skills or accomplishments. They might say: "I dabble in Python." And little 'ol insecure me would open his big mouth and say something like, "Oh yeah. I've coded so many algorithms in Python. I write Python in my sleep."

And then I'd go home and google that developer's name, and realize they were a core contributor to a major Python library. And I'd kick myself.

I quickly learned not to boast of my accomplishments or my skills. There's a good chance a person you're talking to can code circles around you. But most of them would never volunteer this fact.

There's nothing worse than confidently pulling out your laptop, showing off your code, and then having someone ask you a bunch of questions that you're wholly unprepared to answer.

My first few months of attending events was a humbling experience. But these events energized me to keep pushing forward with my skills.

Soon people around southern California would start to recognize me. They'd say: "I keep running to you at these events. What's your name again?"

One night a dev said, "Let's follow each other on Twitter." I had grudgingly set up a Twitter account a few days earlier, thinking it was a gimmicky website. How much could you really convey with just 140 characters? I had barely tweeted anything. But I did have a Twitter account ready, and she did follow me.

That inspired me to spend more time refining my online presence. I made my LinkedIn less formal and more friendly. I looked at how other devs in the community presented themselves online.

Within a few months, I knew people from so many fields:

- experienced developers
- non-technical or semi-technical people who worked at tech companies
- hiring managers and recruiters
- and most importantly, my peers who were also mid-career and trying to break into tech

Why were peers the most important? Surely they would be the least able to help me get a job, right?

Well, let me tell you a secret: let's say a hiring manager brings on a new dev, trains them, and they turn out to be really good at their job. That hiring manager is going to ask: where can I find more people like you?

Your peers are one of the most important pieces of your network. So many of my freelance opportunities and job interview opportunities came from people who started learning to code around the same time as I did.

We came up together. We were brothers and sisters in arms. Those bonds are the tightest.

Anyway, all this networking over the months would ultimately come to fruition one night when I walked into the bar of a fancy downtown hotel for a developer event.

But more on that in the next chapter. Now let's talk more about the art and science of building your network.

### Is it Really Who You Know?

You may have heard the expression that success is "less about what you know, and more about who you know."

In practice, it's about both.

Yes – your connections may help you land your dream job. But if you're out of your depth, and lack the skills to succeed, you will not fare well in that role.

But let's assume that you are proactively building your skills. You've followed my advice from Chapter 1. When is the right time to start building your network?

The best time to start building your network is **yesterday**.

But you don't need a time machine to do this. Because you already have a network. It's probably much smaller than you'd like it to be, but you **do** know people.

They may be friends from your home town, or the colleagues of your parents. Any person you know from your past – however marginally – may be of help.

因此，第一步是对你认识的人进行全面盘点。请不要担心，我并不是要你现在就去接触任何人，也不是在考验你的人际关系。

三思而后行，先制定一个行动计划。

首先，让我们一起来列出所有你认识的人。

### 如何打造个人关系网看板

从创建一个熟人清单开始。

你可以使用电子表格，也可以像销售人员那样使用客户关系管理工具（CRM）来做这件事。但就我们这里要做的事情而言，它们可能有点大材小用了。

我推荐使用像 Trello 这样的看板工具，它是免费的。

你将创建五大列：“待评估”、“待联系”、“待回复”、“最近联系”、“暂不联系”。

然后创建标签，这样你就可以根据你对他们的了解程度对他们进行分类了。这里有一些可供你参考的标签想法："儿时好友"、"家庭的朋友"、"前同事"、"同学"、"参加技术活动认识的朋友"。

现在你可以开始创建卡片了。每张卡片可以只有他们的名字，如果你有时间的话，可以在卡片上添加一张照片。

这是我创建的 Trello 看板，你可以从中得知个人关系网看板可能是什么样子的。我使用了我最喜欢的童年电影（1989 年的经典电影《忍者神龟》）中的人物。

<figure><img src="https://www.freecodecamp.org/news/content/images/2023/01/Personal_Network_Board___Trello_--.png"><figcaption>我的个人关系网看板：副业中一起打击犯罪的朋友们</figcaption></figure>

你可以开始从你的社交媒体帐号，甚至你老旧的毕业纪念册（如果你有的话）添加联系人。

他们中的许多人不会再有任何帮助。但为了全面起见，我建议你依然添加他们。你永远不知道什么时候你会想起："噢……某某在 XYZ 公司得到了一份工作，我应该与他们联系。"

这个过程可能要花一两天的时间。但要知道，这是一项投资。这个看板能够在你的职业生涯中为你所用。

你可能会认为“我不需要这样做，我已经有一个领英账户了”。这或许能行得通，但是领英又大又杂。但你想在这里让信号最大化，让噪音最小化。这也是我鼓励你创建这个专门的个人关系网看板的原因。

在你把人添加到你的看板的同时，还可以给他们贴上标签。花点时间来研究看板中的每一个人。他们这些天都在忙什么？他们有工作吗？还是在开公司？

当你发现了和他们有关的事情，可以在每张卡片上添加笔记。他们最近是否参加了跑步 5 公里的募捐活动？他们的祖母最近是否庆祝了九十大寿？这些信息看起来可能无关紧要。但如果某个人在社交媒体上分享这些事情，那就说明这些事情对他们来说很重要。

努力对人们产生兴趣。发现他们的日常生活，发现他们的抱负。通过了解他们的动机和目标，你将更深入地洞察到你如何才能帮到他们。

正如我之前所说，缔结盟友的最佳方式是帮助他人。我们将在稍后详细讨论这个问题。

对于你添加到个人关系网看板中的每个人，逐一思考他们是否值得联系，然后把他们放入“待联系”或“暂不联系”中。

你可能想知道：为什么这一列叫 “暂不联系”？因为你永远不知道认识的某个人在何时会帮上忙。永远不要把任何友谊或熟人关系视为理所当然。

在你填满看板，给每个人贴上标签，并将他们分门别类之后，就可以开始联系了。

### 如何为关系网延伸做准备

在联系并试图给人留下印象时，请牢记：简单为上，不要啰嗦。

大家都很忙，他们并不能记住太多和你有关的事情。如果你想完全讲清楚自己是谁，最好方法是写一份个人简历。

#### 如何在社交媒体写个人简历

你希望自己的信息在你所有的社交媒体账户中都是一致的。

以下是我的自我介绍：

“我叫 Quincy，是 freeCodeCamp 的一名老师，住在德克萨斯州的达拉斯。我可以帮助你学习编程。”

去写你自己的简历吧。看看你能否把它压缩到 100 个字甚至更少。尽量避免使用花哨的词语或专业术语。

把你的身份提炼成几个字可能很难，但这是一个很重要的过程。

记住：人们很忙，他们并不需要知道你的生活往事。随着你对他们的了解的深入，你可以慢慢地说出更多和你有关的细节。随着时间的推移，他们也会在问你问题的同时更好地了解你。

好了，记得准备好一张带有你的笑脸的照片。

#### 如何制作社交媒体头像

如果你有钱，直接去找一个当地的摄影师，付钱让他们给你拍一些专业的头像。

或许你有一个从事摄影的朋友，他可以免费为你拍照。

我自己使用预装在 MacOS 上的 Photobooth 拍了头像。我的朋友在 Photoshop 中花了大约 10 分钟修正了一些背景和阴影。他可能使我的牙齿看起来要略微白了一点。下面是我的头像：

<figure><img src="https://www.freecodecamp.org/news/content/images/2023/01/Michael_Headshot_B_W_Full_heic.png"><figcaption>我的头像：我在任何地方都使用这张照片</figcaption></figure>

一定要用你的眼睛微笑，这样你才不会看起来像个机器人。或者更好一点，想一些非常有趣的事情，我就是这样做的。然后，你的笑容就会显得很真诚。

从不同的角度拍很多照片，然后使用最好看的那一张。

我建议你使用一张看起来和你的日常生活贴近的始终如一头像。不要使用试图将你的吸引力最大化的经过大量修改的照片。你希望人们能够在活动中通过你的照片认出你。而且，你不想让美颜吓到别人，你想让他们感到安心。

说到让人安心：不要戴墨镜，也不要努力地看起来很酷。你要看起来友好、平易近人。在这方面，有的一个很好的带有讽刺意味的测试：看看你的照片。如果你迷路了，你在街上看到这个人，你会有勇气向他们问路吗？

选好了头像之后，就在所有的地方使用同一张照片。把它放在你所有的社交媒体账户上。

在你的个人网站上使用它，甚至你还可以[将个人照片添加到你的电子邮件帐户](https://www.freecodecamp.org/news/gmail-profile-picture/)。

我建议常年来使用同一张照片。每次你改变它，都会冒着有些人不会立即认出你的风险。即使是灯光、角度或背景的细微变化，也会使人们失去熟悉感。

一定要保留一张高清版本的照片。这样，当你在别人的会议上的演讲，或他们的播客中的客串的时候，他们就可以用这张照片来宣传了。(别担心，假以时日，你能做到的）。

### 如何与过去的人联系

现在简历和照片都已就绪，你已经做好与人交谈的准备了。

15 年前，我会说你应该给人们打电话，而不是给他们发消息。但随着智能手机的出现，相关文化已经发生了很大的变化。大多数人都不会很好地回应电话了。

同样，我也不建议在谈话接近尾声的时候才邀请别人去喝咖啡或吃午餐。人们很忙，可能会觉得这个请求有些尴尬。

你需要直奔主题，越快越好。

那么，你需要奔入的主题是什么呢？

本质上如下：

1. 我知道你
2. 我喜欢你
3. 我敬佩你的做的事情

就是这样。

人们喜欢被了解，喜欢被人喜欢，喜欢自己做的事情和生活受到关注。

我们中的大多数人都会在生日当天得到认可。在过去，人们可能会通过短信、社交媒体，甚至打电话的方式祝我们生日快乐。

但一年中的其它 364 天呢？人们也喜欢在这些日子里得到认可。

哈哈，这里有一个认可别人的简单方法。

第 1 步：研究这个人。在谷歌上搜索他们，阅读他们最近发布在社交媒体上的内容，阅读他们的领英账户。如果他们发布了家庭照片，更要多花点时间看一下。

第 2 步：想一想你可以说点什么，从而让他们的一天变得更加美好。

第 3 步：选择一个他们最近比较活跃的社交媒体平台，直接给他们发一条信息。

我将分享一个模板，但永远不要逐字逐句地使用任何模板，因为如果收件人将你的信息,用谷歌进行搜索，他们会发现这是一个模板，而你所有的善意将被误解。

如果我突然给一个几个月或几年没有联系过的人发信息，我会说这样的话:

"嘿，[姓名]，我希望你的[新的一年/春天/一周]有一个有趣的开始。祝贺你[新工作/晋升/新生儿/完成项目]。看到你在外面做事情，很受鼓舞。"

像这样简短而有针对性的东西。问候+祝贺+赞美。这就是基本公式。

不要只是说出来。

真的想让这个人感到被认可。真的想照亮他们的一天。真的想鼓励他们继续向他们的目标迈进。

人类非常善于察觉不诚恳。不要试图过度推销。不要给他们任何理由去想 "这个人想从我这里得到什么"。

这就是为什么这方面最重要的事情是：要简短。要尊重人们的时间。没有人想要一封长信，他们会觉得有义务对其进行长时间的回应。

因为，跟我说一遍 **人很忙**。

### 如何建立更深入的联系

因为人们是如此忙碌，他们往往会因为这些陌生人能为他们做什么而更多地看到陌生人:

- 这个人开着巴士送我去上班。
- 这个人按照我喜欢的方式给我做饮料。
- 这个人在人力资源部门回答我关于休假的问题。
- 这个人为我准备了一份 acid 爵士乐的播放列表，让我在写代码时听。
- 这个人每周都会给我发送有用的电子邮件，提供免费的编程资源。

在某种程度上，你就是你为人们所做的。

我知道，我知道。这听起来可能过于简化。甚至愤世嫉俗。而对于你生活中的亲密朋友和家人来说，这 100%不是真的。

但是对于那些几乎不认识你的人--他们只是在日常工作中遇到你--这可能是他们对你的看法。

你必须给人们一个关心你的理由。 你必须激励他们更多地了解你。

在你能成为某人的亲密朋友之前，他们真正关心的人，并且在你不在的时候想到的人，你需要从一个对他们有帮助的人开始。

而这正是我们在这里要做的。我们要通过提供帮助来建立更深的关系。

这将是一个漫长的过程。而且你应该在找工作之前提前开始。你最不希望看到的是，有人认为 "哦，你只是因为需要我的东西而伸出援手"。

恰恰相反，你伸出援手是因为你有东西可以提供给他们。

毕竟，你拥有一个人可以获得的最强大的技能之一。使机器服从你的意志的能力。你是一个程序员。

![c_BasicProgramming_Picture_front](https://atariage.com/2600/carts/c_BasicProgramming_Picture_front.jpg)这就是擅长编码的感觉。

或者，至少，你正在成为一个人的道路上。

所以你已经有了一个很好的理由去接触人们。

你可能听说过 **冷电话** 这个词。这就是你在对某人几乎一无所知的情况下给他打电话，并试图向他们推销东西。这并不容易，绝大部分的冷电话都以对方挂断而告终。

但是，你对对方了解的信息越多，电话就越温暖，你就越有可能成功。

现在，你在这里不是在卖东西。正如我前面提到的，你也不是在给他们打电话。你是在给他们发送一条直接信息。

也许这是通过 Twitter、LinkedIn、Discord、Reddit。 任何地方。但你是用一段文字向他们伸出援手。

正如我所说，最有力的开场白,最有可能得到回应的方法，是随意地提供帮助。

如果我在做这件事，这里有一个我将使用的简单模板。记住不要逐字逐句地使用这个模板。用你自己的声音重写，你会怎么对朋友说。\:

> "嘿[姓名]，祝贺你[新工作/晋升/新生儿]。我一直在学习一些编程，并正在建立我的作品集。我立刻想到了你，你是一个能完成很多事情的人。有没有什么工具或应用程序可以让你的生活更轻松？我也许可以为你编码，作为我的练习。"

这是一个强有力的方法，因为它是个性化的，不会让人觉得是自动的。如今，人们收到如此多的自动信息，以至于他们很快就会无视任何甚至类似于自动信息的东西。

这就是为什么我手动发送我所有的信息，而不依赖自动化。慢慢地逐一编写信息比试图用脚本或邮件合并来节省时间更好。

最快的被屏蔽的方法是给别人发消息说 `嗨，你好吗？` 其中明显少了一个名字,证明这个消息是一个模板。

有时我收到的信息用我的姓而不是我的名。`嘿，拉森。` 什么，我现在是在军事学校吗？

而且，LinkedIn 上的很多人已经开始在他们名字的开头加上一个表情符号。这使得检测自动信息变得很容易，因为没有人会在他们的直接信息中包括这个表情符号。

当一条信息的开头是 "嗨🍜莎拉，你在找新工作吗？" 那么你就知道这是一条批量信息。

还要注意的是，我上面的模板并没有说 "我们是同学 "或类似的话。除非你几天前刚认识某人，否则你不应该说明你们俩是怎么认识的。

为什么？因为提醒人们你们是如何认识的行为本身会促使一些人退一步想："哎呀，我几乎不认识这个人。"

### 如何让对话持续下去

同样，你的目标是得到他们的回应，这样你就可以开始一个来回的对话。

这些信息传递平台有一种休闲的感觉。保持随意。

不要发送单一的、多段落的信息。保持你的信息短而快。你不想让他们觉得回复你是件苦差事。

一旦你让他们回复你，就开始在你的个人网络板上做笔记，这样你以后就能记住这些事实。

也许他们确实有一些应用程序的想法或工具的想法。很好。向他们询问有关问题。看看你是否可以为他们建立它。

从画出用户界面的简单模型开始。如果你想看起来更复杂，就用绘图纸。给它拍张照片，然后发给他们。"像这样的东西？"

这将确立你对帮助他们是认真的。而且我愿意打赌，对大多数人来说，这将是一种新的体验。

"你在帮助我？你在为我创建这个应用程序？" 这将是一种奉承，他们将有可能记住它。即使这个应用程序本身没有任何进展。

从那里开始，你可以随着谈话的流程走。也许它消失了。不用担心。随它去吧。你可以在几周后找到一个理由来重新拾起对话。

这些社交媒体直接信息的好处是整个信息记录都在那里。下次你给他们发信息时，他们可以直接滚动并看到 "哦，这是那个提议为我建立应用程序的人"。没有更多的 "你是谁来着？"的疑问，而你可能在面对面的谈话中得到。

再次重申，保持一切休闲和乐观。 如果感觉谈话进行得很慢，那没问题。 因为您将进行许多其他对话。保持热度，你将成为一只忙碌的蜜蜂，建立你的人际联系。

### 如何认识新朋友并扩大你的人际网络

我们已经谈到了如何与你已经认识的人联系。这些联系仍然存在，即使它们多年来已经有点萎缩了。

但你如何建立全新的联系？

这不是一件容易的事。但我有一些建议，可以使这个过程不那么令人生畏。

首先，第一次与人见面，比在网上见面要有效的多。

当你见到某人的时候，你的记忆有更多的信息可以获取:

- 这个人的长相，他们的姿势，以及他们如何在空间中移动
- 他们的声音和他们说话的方式
- 灯光、声音、香气、温度和场地的总体感觉
- 还有许多其他的小细节，这些都会在你的记忆中留下烙印

与一个人当面交谈 10 分钟，比来回几十条信息，跨越几周的通信建立更深的联系。

这就是为什么我强烈建议：走出去，在当地的活动中认识人们。

### 如何在城市周边的当地活动中结识朋友

哪些活动？如果你住在一个人口稠密的城市，你可能有大量的选择供你支配。你可能每周都能去参加几个晚上的科技活动，而且通勤时间最少。

如果你住在一个小镇上，你可能不得不坚持在当地的聚会上认识人。书展、冰激凌社交活动、体育赛事。

如果你去教堂、清真寺或寺庙，也要认识那里的人。

是的，我知道这可能听起来很荒谬。"在足球比赛中站在我旁边看台的那个人？他们会以某种方式帮助我找到一份开发商的工作？"

也许吧。也许不是。但不要把人撇开。

那个人可能经营一个小企业。

他们可能和一个在财富 500 强公司担任工程副总裁的朋友一起上学。

也许他们也是一名软件工程师。毕竟，我们有数以百万计的软件工程师在那里。而且我们并不都住在硅谷。 😉

当你遇到一个新的人时，你不想立即掏出你的手机，说 `我可以把你加入我的LinkedIn 的联系人吗？`

相反，你要表现得冷静。介绍一下自己。

**记住他们的名字。**名字是建立关系不可或缺的。如果你不善于记名字，就练习记住它们。你可以在看电视节目或电影时，试着记住每个角色的名字,不管他们是不是大明星，来练习。

如果你忘记某人的名字，不要猜测。只要说 `你叫什么名字来着`，第二次一定要记住它。

与他们握手或握拳。与他们谈论任何感觉自然的话题。如果谈话结束了，不用担心。随它去吧。

你随着时间的推移建立关系。这不是指与某人相处的总时间,而是指你在较长的时间跨度内与该人见面的次数。

有一个很好的机会，你会在未来再次见到这个人。也许几周后，在同一个确切的地点。而就是你采取行动的时候:

`你好[姓名]，[你们上次谈的事情]进展如何？`

从中断处继续对话。 如果他们看起来像是对您的个人网络板 (Personal Network Board)有帮助的人，请问他们 `嘿，你接下来 [星期几] 在做什么？你想和我一起去 [其他即将举行的本地活动] 吗？”`

始终牢记你即将到来的一周的活动，所以你可以邀请人们加入你。

这是一个让人们在一个安全的公共空间与你一起玩耍的好方法。而且你还提供了一些有价值的东西,让他们意识到即将到来的活动。

如果他们看起来感兴趣，你可以说 "太棒了。我有什么最好的方式给你留言，并把活动的细节告诉你？"

你现在有了他们的电子邮件或社交媒体或电话号码，你们的关系可以从那里展开。

这可能听起来像是一种慢热的方法。为什么如此谨慎？

同样，人们很忙。聪明人会保护他们的时间和他们的个人信息。

外面有太多的吸血鬼想利用人们,试图向他们推销东西，诈骗他们，让他们加入他们的多层次营销计划，或以其他方式向他们传教。

让其他人克服这种不信任的最好方法是：在以前的接触中已经作为一个通情达理的人，出现在他们的视野上。

### 如何利用你的人际网络

我们将在第 4 章详细讨论如何利用您的网络。现在，将您的网络纯粹视为时间和精力的投资。

我喜欢把我的人际关系想象成一个果园。 我正在建立关系。 照顾他们，确保他们健康。

谁知道这些关系何时会长成大树并结出果实。 目标是继续植树，在未来的某个时候，这些树将帮助维持你的生命。

不断散发正能量。 不断提供帮助人们使用你的技能，甚至是你自己的人际关系。（在你认识的两个人之间进行礼貌的介绍很少是一个坏举动。）

做一个善良、体贴、乐于助人的人。

永远不要对求职过程的缓慢感到不耐烦。

永远不要让自己感到被轻视或冷落。

永远不要让自己嫉妒别人的成功。

有因就有果。有一天你会收获你所播种的东西。如果你播种的是正能量，你就为自己的丰收做了准备。

## 第三章：如何建立你的声誉

> "获得良好声誉的方法是努力成为你希望出现的样子"。  苏格拉底

现在你已经开始建立你的技能和你的人际网络，你已经准备好开始建立你的声誉。

你可能从零开始，一个完全的技术新人。或者你可能已经有了一些信誉，你可以从你的其他工作中带来。

在本章中，我将分享如何在同行中建立良好声誉的实用技巧。这将是获得自由职业者客户、第一份工作以及在事业上取得进展的关键。

但首先，我是如何建立我的声誉的。

### 故事时间：一位 30 多岁的教师是如何建立起开发者的声誉的？

*上一次是在故事时间。昆西开始建立他的网络，包括开发人员、企业家和科技界的招聘经理。他经常参加城市周围的黑客空间和科技活动。但他还没有爬上竞技场，测试自己的实力……*。

当我终于鼓起勇气去参加我的第一次黑客马拉松时，我的编码之旅已经有几个月了。

有一天，我遇到了一个特别讨厌的错误，我不知道如何解决它。所以我做了很多人在这种情况下会做的事情。我通过浏览网页来拖延时间。这时我看到了它。创业周末（Startup Weekend EDU）。

创业周末是一个长达 54 小时的比赛，包括建立一个应用程序，然后将其提交给评审团。这些活动也奖励你的编码、设计和创业知识。

这个特别的活动--在硅谷的中心地带举行，有一个由教育家和教育企业家组成的评审团。由于我有成人教育的背景，这似乎是我第一次参加黑客马拉松的理想选择。

我把这个活动告诉了史蒂夫。然后我说出了那句神奇的话。"由我来开车"。这很好，因为史蒂夫没有驾驶执照。

有了史蒂夫的加入，我们与来自圣巴巴拉黑客空间的几个开发人员组成了我们的团队。

我花了几周时间准备这次活动，研究评委和他们工作的公司。我研究了赞助商。当然，我还像少林寺的和尚一样练习编码。

终于，经过一个月的准备，迎来了大周末。 我们挤进我的 2005 年丰田卡罗拉，车上的透明涂层已经剥落，放上一些充满活力的音乐，开始了我们 5 小时的车程。

在路上，我们讨论了我们应该建造什么。当然，它将是以教育为重点的。最好是满足高中生的需求，因为这些是评审人员的公司所关注的年级。

但这个应用程序应该做什么？它将如何使人们的生活更轻松？

我回想了一下我自己在高中的时候。我没有什么可说的，因为我只上了一年就退学了。(我确实设法学习并通过了普通教育证书，我们称之为 "足够好的学位"，同时在 Taco Bell 工作，最后才上了大学）。

但我确实记得高中时的一个痛点，在这么多年后仍然响起。英语论文。

现在我喜欢写作。但我不喜欢用 MLA 格式写作，因为它有严格的引证规则。我曾经害怕准备工作引证页。我的老师总是会因为我的引文格式不正确而扣我的分。

在听了车上其他乘客的很多好主意后，我开始说了。 我说：“我有个主意。我们应该编写一个应用程序，为您创建引文。”

而有人笑着说： "看不见了。"

史蒂夫说，“嘿，这是个好名字。我们可以用 `C` 称它为 `Out of Cite`。

我们都笑了起来，觉得自己很聪明。然后我们开始讨论实施细节。

当我们到达会场时，那里有大约 100 名其他开发人员。那是一个开放式的办公空间，低矮的隔间两边是白板。

我听到了关于其中一个开发者的窃窃私语。"嘿，是那个去年赢得比赛的家伙。" 我听到人们说。他们向一个被粉丝包围的、看起来很自负的开发者打手势。"也许他会让我加入他的团队。"

活动开始时，大家纷纷发表意见。任何人都可以走到房间前面，拿起麦克风，为他们想要建立的应用程序做 60 秒的演讲。

我太紧张了，感觉就像一个外星人要从我的胸膛里冲出来。 所以很自然地，我排在第一位。 撕掉创可贴，对吧？

我满头大汗，疯狂地打着手势，飞快地完成我的演讲。我说了这样一段话。"引文很烂。我的意思是，它们并不糟糕。它们是必要的。你需要把它们添加到你的论文中。但准备引文的工作很糟糕。让我们建立一个应用程序，为你填写你的工作引文页。谁支持我？"

房间里很安静。然后人们意识到我已经讲完了，他们给了我一个强制性的掌声。主持人从我手中拿过麦克风，把它交给下一个人，而我则蹦蹦跳跳地回到了我的座位。

投球结束后，就到了组队的时间。我们的圣巴巴拉小分队互相看了看，说 "我想我们是一个团队"。

我们弄清了 WIFI 密码，抢到了最合适的工作场所：一个角落里的办公室，有一扇可以真正关闭的门。

我开始在白板上写下 UI 模型。我说："我们想要的东西总是一击即中。就在你的浏览器的菜单栏里。"

"像一个浏览器插件，"史蒂夫说。

"是的。让我们建立一个浏览器扩展。"

我向他们展示了论文可能需要的三种格式的例子。MLA，APA，和 Chicago。

"我们能不能同时生成这三种格式，让他们可以直接复制粘贴？我问道。

"我们可以做得更好，"史蒂夫说。"我们可以为他们每个人设置一个按钮，把引文直接放到他们的剪贴板中。"

我们工作得很快，在星期五晚上结束时创造了一个简单的 MVP（最小可行产品）。它所做的只是抓取当前网站的元数据，并将其结构化为一个引文。但它成功了。

由于这是我第一次参加黑客马拉松，我不想承受住在旅馆里的压力。所以我花钱买了一个酒店房间。我们有两张双人床，所以每天晚上我们都会轮流睡在地板上。

星期六早上，我们的野心越来越大。我走到白板前，对团队说。"引用网站是伟大的，所有的。但学生们引用的很多东西都是在书本或学术论文中。我们也需要能够为这些东西生成引文。"

我们找到了一个 API，我们可以用它来获取基于 ISBN（用于书籍的序列号）的引文信息。我们还写了一个脚本，可以根据 DOI（用于学术论文的序列号）搜索学术论文，然后从结果页中刮取数据。

到了星期六晚上，我们的浏览器扩展的代码终于完成了。于是我坐下来，开始准备演示幻灯片。我把很多最后的编码工作留给了我的队友，而我则反复排练了几个小时的演讲。

尽管轮到我在床上睡觉，但由于紧张，我几乎无法闭目养神。我在这里，就在科技生态系统的中心。硅谷。

作为一名教师，我经常在我的同行面前发表演讲，有时是几十个人。但这是不同的。

几个小时后，我将向一屋子雄心勃勃的开发者发表演讲。还有评委。拥有博士学位的人，其中一些人已经创办了自己的科技公司。他们将对我们的工作进行评估。我很害怕自己会以某种方式搞砸。

由于无法入睡，我打开了我的电子邮件。创业周末的工作人员发出了一封电子邮件，其中包括一本书的 PDF。这是一本非官方的科技创业经典 [顿悟的 4 个步骤](https://www.amazon.com/Four-Steps-Epiphany-Successful-Strategies/dp/1119690358?_encoding=UTF8&qid=&sr=&linkCode=ll1&tag=out0b4b-20&linkId=662e9d222ccd9aa050d3ad29438e74e3&language=en_US&ref_=as_li_ss_tl) 和 [精益创业](https://www.amazon.com/The-Lean-Startup-Eric-Ries-audiobook/dp/B005MM7HY8?_encoding=UTF8&qid=&sr=&linkCode=ll1&tag=out0b4b-20&linkId=13b3c19bdbda93658336cf7c69e27100&language=en_US&ref_=as_li_ss_tl) 的混搭。

现在，我已经读过这些书，因为它们是 2010 年代初期想要构建软件产品的任何人的必读书籍。 但我还阅读了数十本其他创业书籍。 他们的很多见解都汇集在一起，形成了一堆建议。

凌晨 4 点，我无法入睡。 所以我才开始阅读。 这些书真正触及的一件事是构建人们愿意支付的东西。 客户验证的最终形式。

就在那时我意识到：你知道什么能真正推动我的演讲越过终点线吗？ 产品市场契合度的证明。 证明我们正在构建的应用程序解决了人们遇到的实际问题。 如此之多，以至于他们会打开钱包。

This gave me an idea. I should take our app on the road and sell it to people.

But it was Sunday morning. Where was I going to find potential customers? Well, our hotel just happened to be located near the main campus of Stanford University.

I drove my team to the event venue, waved goodbye and said: "I'll come back when I have cold, hard cash from customers."

My teammates chuckled. I'm not sure if they thought I was serious. They said, "Don't be late for the pitch."

But I was serious. I had a prototype of the app running on my laptop. I punched Stanford into my GPS and embarked on my mission.

Now, I studied at a really inexpensive state university in Oklahoma. So I felt really out of my depth when I rolled up to one of the premier universities in the world.

Stanford costs $50,000 per year to attend. And I pulled into their parking lot driving a car worth 1/10th of that.

The campus was a ghost town this time of the week. But a palatial ghost town, none the less. Bronze statues. Iconic arches everywhere.

I asked myself: where are the most high-achieving, hard-core students this time of day? The ones who don't have time to waste on manually creating their Work Cited pages?

I walked into the main library, right past the security desk and a sign that said "no soliciting."

I strode around the stacks, finding a small handful of people studying. This one kid was studiously taking notes as he read through a thick textbook. Bingo.

I slid into the seat next to him. "Psst. Hey. Do you like citations?"

"What?"

"Citations. You know, like, work cited pages."

"Um..."

"You know, the last page of your paper, where you have to list all the..."

"I know what a work cited page is."

"OK. Well check this out." I pulled my jacket to the side like a drug dealer, and whipped out my $200 netbook. He humored me for a moment while I delivered my awkward sales pitch.

I said: "Here. I've got this browser plugin. I go to any website, click the button, and voilà. It will create a citation for me."

The kid raised his eyebrows. "Can it do MLA?"

I bit back my excitement and said, "MLA, APA, and even Chicago. Watch." I clicked the button and three citations appeared – each with its own copy-to-clipboard button.

The kid nodded, seeming somewhat impressed. So I attempted to close the sale.

"What if I told you that I was about to launch this app with a yearly subscription. But if you sign up now, I'll get unlimited access not for a year, but for a lifetime."

The kid thought for a moment.

I had heard that silence was the salesperson's best friend. So I sat there for an uncomfortably long time in total silence, staring him down.

Finally he said: "Cool I'm in."

"Awesome. That'll be twenty bucks."

The kid recoiled. "What? That's expensive."

This was of course the era of venture capital-subsidized startups, where Uber and Lyft were losing money on every ride in a race for market share. So the kid's reaction was not totally surprising.

But I thought fast. "Well, how much cash do you have on you?"

He fumbled with his wallet, then said, "five bucks."

I looked at the crumpled bill and shrugged. "Sold."

He smiled, and I sent him an email with instructions for how to install it. Then I said, "One more thing. Let's take a picture together."

I put my phone on selfie mode. He started to smile, and I said, "Here. Hold up the five dollar bill."

I spent another hour pitching people in the library, and managed to get another paying customer as well. Then I raced back to the event venue to finalize our prototype with the team.

That afternoon, I gave what I still think is the best presentation of my life. We live-demoed the working app – which worked perfectly.

We ended the presentation with the photos I'd taken, posing with Stanford students who were now our paying customers. When I held up the cash, the audience burst into applause.

Overall, it was one of the most exhilarating experiences of my life. We came in second place, and won some API credit from one of the companies who sponsored the event.

At the after party, I chipmunked some pizza, so I'd have more time to network with everyone I could. I connected on LinkedIn. I followed on Twitter. I snapped selfies together with people and used the heck out of the event's hashtag.

This was a watershed moment in my coding journey. I had proven to the people in that room that I could help design, code, and even sell an app. And more importantly, I'd proven it to myself.

### Riding the Hackathon Circuit

From that moment on, I was hooked on hackathons. That year, I participated in dozens of them. I became a road warrior, railing up and down the coast, attending every competition I could.

It would be much harder from here on out. I didn't have a team anymore. I was on my own.

I'd arrive, meet as many people as I could, then go up and pitch an idea I thought might win over the judges.

Sometimes people joined my team. Sometimes I joined other people's teams.

I didn't merely want to design apps – I wanted to code them, too. And my reach often exceeded my grasp.

There were many hackathons where I would still be trying to fix bugs down to the final minutes before going on stage. Sometimes my apps would crash during live demos.

One hackathon in Las Vegas, I managed to screw up the codebase so badly that we just had to use a slideshow. I sat in the audience with my head in my hands, watching helplessly as my team member demonstrated how our app would hypothetically work – if I could have gotten it to work. We didn't fare well with the judges.

But I kept grinding. Kept arriving in new towns, checking into the hostel, and hitting the venue, and eating as much free pizza as I could.

My teams had come in second or third so many times I could barely keep count. But we'd never managed to outright win a hackathon.

### Breaking Through

That was until an event in San Diego. I'll never forget the feeling of building something that won over the audience and judges to the extent that our victory felt like a foregone conclusion.

After they announced us as the winner, I remember sneaking out the back door to a parking lot and calling my grandparents. I told them that I'd finally done it. I'd helped build an app and craft a pitch that had won a hackathon.

I don't know how much my grandparents understood about software development, or about hackathons. But they said they were proud of me.

With them gone now, I often think back to this conversation. I cherish their encouragement. Their faith in a 30-something teacher who was trying like crazy to become a developer.

I kept going to hackathons after that. I kept forming new teams and learning new tools along the way. You never forget the first time you get an API to work. Or when you finally grok how some Git command works. And you never forget the people hustling alongside you, trying to get the app to hold together through the demo.

The TechCrunch Disrupt hackathon. The DeveloperWeek hackathon. The ProgrammableWeb hackathon. The $1 Million Prize Salesforce Hackathon. So many big hackathons and so much learning. This was the crucible where my developer chops were forged.

Not only did I manage to build my skills and my network along the way – I now had a reputation as someone who could actually win a hackathon.

I could ship.

This made me a known quantity.

And that reputation was crucial to getting my first freelance clients, my first developer job, and most importantly – trusting my own instincts as a dev.

### Why Your Reputation is So Important

The role of reputation in society goes way, way back to human prehistory. In most tribes and settlements, there was some system to keep track of who owed what to whom.

Before there was cash, there was credit.

This may have been a written ledger. Or it may have been an elder who simply kept all these records in their head.

Beyond raw accounting, there was also a less tangible, but equally important vibe that people carried with them.

"John sure knows how to shoe a horse."

Or "Jane is the best story teller in the land."

Or "Jay's courage in battle saved us against the invaders three winters ago."

You'll note that these examples all involve someone being good at something. Not merely being a good, likable person.

It certainly helps to be a chill, down-to-earth human being. But this isn't The Big Lebowski, and we aren't going to survive on our charm alone.

![image__2000-1338_](https://www.freecodecamp.org/news/content/images/2023/01/image__2000-1338_.png)The Big Lebowski (left). He had no job, he had no skills, he had no energy. But he had chill, out the wazoo.

It's easy for a developer to say: "Oh yeah. I know JavaScript like the back of my hand. I can build you any kind of JavaScript application you need, running on any device you can think of."

Or to say: "I ship code under budget and ahead of time – all the time."

But how do you know they're not exaggerating their claims?

After all, a devious man once said:

> "If you can only be good at one thing, be good at lying.
>
> Then you're good at everything."

(The true provenance of this quote is unknown. But I like to imagine it was said by a 1920s con man wearing a top hat and a monocle.)

Anyone can lie. And some people do.

Earlier in my career, I had the unpleasant task of firing a teacher who had lied about earning a master's degree. The years went by and nobody caught it.

Every year, he would lie on his annual paperwork, so that he could get a higher pay raise than the other teachers. And every year, he would get away with it.

But one day a small discrepancy tipped me off. I reviewed his file, called up some university record departments, and discovered that he had never bothered finishing his degree.

When I caught him it was a real Scooby Doo moment. "And I would have gotten away with it, if not for you darn kids."

It sucked to know that this person was teaching at the school for years and getting paid more than many of the other teachers – just because he was willing to lie.

The spoils of lying are always there, glistening. Some people are willing to give in to that temptation.

Employers know this. They know you can't trust just any person who claims to know full-stack JavaScript development. You have to be cautious about who gets a company badge, a company email address, and the keys to your production databases.

This is why employers use behavioral interview questions – to try and catch people who are more capable of dishonesty.

Call me naive, but I believe that most people are inherently good. That most people are willing to play by the rules as long as those rules are reasonably fair.

But if even one person out of ten would be a disaster hire, it means that all of us are subjected to higher scrutiny.

The worst-case scenario is not merely someone who lies to make more money. It's someone who sells company secrets, destroys relationships with customers, or breaks laws in the name of inflating their numbers.

History is rife with employees who unleashed catastrophic damage upon their employers, all for their own personal gain.

Thus, the developer hiring process at most big companies is paranoid as heck. Maybe it should be. But unfortunately, this makes it harder for *everyone* to get a developer job – even the most honest of candidates.

As developers, we need proof that our skills are as strong as we say they are. We need proof that our work ethic is as steadfast as our employers need it to be.

That's where reputation comes in. It reduces ambiguity. It reduces counter-party risk. It makes it safer for employers to make a job offer, and to sign an employment contract with you.

This means that – if you have a strong enough reputation – you may be able to get into the company through a side door – rather than the front door that other applicants line up for.

Some companies even have in-house recruiters who can fast track your interview process. A strong reputation can also help you command more bargaining power during salary negotiations.

So let's talk about how you can build a strong reputation, and become sought-after by managers.

### How to Build Your Reputation as a Developer

There are at least six time-tested ways you can build your reputation as a developer. These are:

1. Hackathons
2. Contributing to open source
3. Creating Developer-focused content
4. Rising in the ranks working at companies who have a "household name"
5. Building a portfolio of freelance clients
6. Starting your own open source project, company, or charity

#### How to Find Hackathons and Other Developer Competitions

Hackathons represent the most immediate way to build your reputation, your network, and your coding skills at the same time.

Most hackathons are free, and open to the public. You just need to have the time and the budget to travel.

If you live in a city with lots of hackathons – like San Francisco, New York, Bengaluru, or Beijing – you may be able to commute to the event, then go home and sleep in your own bed.

Even though I lived in Santa Barbara, which only had hackathons once every few months, I did have an old classmate in San Francisco who let me crash on his couch. This gave me access to many more events.

Hackathons used to be hard core events. People would knock back energy drinks and sleep on floors, all to finish their project by pitch time.

But hackathon organizers are gradually becoming more mindful about the health and sustainability of these events. After all, a lot of participants have kids, or demanding full-time jobs, and can't just all-out code for an entire weekend.

The best way to find upcoming events is to just google "hackathon [your city name]" and browse the various event calendars that come up. Many of these will be run by universities, local employers, or even education-focused charities.

If you're playing to win, I recommend doing your research ahead of time.

Who are the event sponsors? Usually it will be Business-to-Developer type companies, with APIs, database tools, or various Software-as-a-Service offerings.

These sponsors will probably have a booth at the event where you can talk with their developer advocates. These are people who get paid to teach people how to use the company's tools. Sometimes you'll even meet key employees or founders at these booths, which can be a great networking opportunity, too.

Often the hackathon will offer sponsor-specific prizes. "Best Use of the [sponsor's] API." It may be easier to focus your time on incorporating specific sponsor tools into your project, rather than trying to win the grand prize. You can still put these down as wins on your LinkedIn or your résumé. A win is a win.

Sometimes the hackathon is just so high profile – or the prize is so substantial – that is just makes sense to try and win the competition outright.

During my time going to hackathons, I was able to win several month's rent worth of cash prizes, several years' worth of free co-working space, and even a private tour of the United Nations building in New York City.

On the circuit, I met people whose main source of income was cash prizes from winning hackathons. One dev I knew managed to win nine sponsor prizes at the same hackathon. He managed to integrate all of those sponsor tools into his project – and also win second place overall.

Don't be surprised if some of the people you run into frequently at hackathons go on to found venture-backed companies, or launch prominent open source projects.

The level of ambition you'll see among hackathon regulars is way, way higher than that of the average developer. These are, after all, people who finish a work week, then go straight into a work weekend. These people are not afraid to leap out of the frying pan and into the fire.

### How to Contribute to Open Source

Contributing to open source is one of the most immediate ways you can build your reputation. Most employers are going to look at your GitHub profile, which will prominently display your Git commit history.

![raisedadead__Mrugesh_Mohapatra__--](https://www.freecodecamp.org/news/content/images/2023/01/raisedadead__Mrugesh_Mohapatra__--.png)The GitHub profile of Mrugesh Mohapatra, who does a ton of platform development and DevOps for freeCodeCamp.org. Note how green his activity bar is. 2,208 contributions in the past year alone.

Many open source project maintainers, such as Linux Foundation, Mozilla (Firefox), and of course freeCodeCamp ourselves, have high standards for code quality.

You can read through open GitHub issues to find known bugs or feature requests. Then you can make the code changes and open a pull request. If the maintainers merge your pull request, this will be a major feather in your cap.

One of the best ways to get a job at a tech company is to become a prolific open source contributor to their repositories.

Open source contribution is a great way to build your reputation because everything you do is right out in public. And you get the **social proof** of having other developers review and accept your work.

If you're interested in building your reputation through open source, here's how to get started.

Read Hillary Nyakundi's comprehensive guide to [getting started with open source](https://www.freecodecamp.org/news/how-to-contribute-to-open-source-projects-beginners-guide/).

### How to Create Developer-Focused Content

Developers are people. And like other people, they want something to do with their time when they're not working, sleeping, or hanging with friends and family.

For many people – including myself – that means spending time in other people's thoughts. Books. Video essays. Interactive experiences like [visual novels](https://www.freecodecamp.org/news/learn-to-code-rpg-1-5-update/).

You can broadly refer to these as "content." I'm not a huge fan of the word, because it makes these works feel disposable. But that's what people call it.

Software development is an incredibly broad field, with so many different topics you could approach. There are developer lifestyle vlogs, coding interview prep tutorials, coding live streams on Twitch, and developer interview podcasts.

There are probably entire categories of developer content that we haven't even thought of yet, which will break over the next decade.

If you're interested in film, journalism, or creative writing, developer content may be a good way to build your reputation.

You can pick a specific topic and gradually come to be seen as the expert.

There are developers who specialize in tutorials for specific technology stacks, for example.

My friend Andrew Brown is a former CTO from Toronto who has passed all the major DevOps exams. He creates [free courses to prepare you for all the AWS, Azure, and Google Cloud certifications](https://www.freecodecamp.org/news/azure-developer-certification-az-204-pass-the-exam-with-this-free-13-5-hour-course/), and also runs an exam prep service.

There are more than 20 million software developers around the world. That's a lot of people who will potentially consume your content, and who will come to know who you are.

### How to Rise in the Ranks Working at Big Companies

You may have seen a developer introduced as an "Ex-Googler" or an "Ex-Netflix engineer."

Some tech companies have such rigorous hiring processes – and such high standards – that even getting a job at the company is a big accomplishment.

There are some practical reasons why employers look at where candidates have previously worked. It reduces the risk of a bad hire.

You can build up your reputation by working your way up the prestige hierarchy. You can ladder from a local employer to a Fortune 500 company, and ultimately to one of the big tech giants.

Of course, working at a giant corporation is not for everyone. I'll talk about this more in Chapter 4. But know that it is one option you have for building up your reputation.

### How to Build your Reputation by Building a Portfolio of Freelance Clients

You can build your reputation by working with companies as a freelancer.

Freelance developers usually work on smaller one-person projects. So this may be a better strategy for building your reputation locally.

For example, if you did good work for a locally-based bank, that may be enough to convince a local law firm to contract you as well.

There is something to be said for being a "hometown hero." I know many developers who can effectively compete with online competition just by being physically present in meetings, and knowing people locally.

### How to Build a Developer Portfolio of Your Work

Once you've built some projects, you'll want to show them off. And the best way to do this is with short videos.

People are busy. They don't have time to pull down your code and run it on their own computer.

And if you send people to a website, they may not fully grasp what they're looking at, and why it's so special.

That's why I recommend you use a screen capture tool to recording 2 minute video demos.

Two minutes should be long enough to show how the project works. And once you've done that, you can explain some of the implementation details, and design decisions you made.

But always, always start with the demo. People want to see something work. They want to see something visual.

Once you've lured people in with your compelling demo of your app running, you can explain all the details you want. Your audience will now have more context, and be more interested.

Two minutes is also a magic length, because you can upload that video to a tweet, and it will auto-play on Twitter as people scroll past it. Auto-play videos are much, much more likely to be watched on Twitter. They remove the friction of having to click a play button, or navigate to another website.

<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="" title="Twitter Tweet" src="https://platform.twitter.com/embed/Tweet.html?creatorScreenName=ossia&amp;dnt=false&amp;embedId=twitter-widget-0&amp;features=eyJ0ZndfdGltZWxpbmVfbGlzdCI6eyJidWNrZXQiOltdLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2ZvbGxvd2VyX2NvdW50X3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0ZndfaG9yaXpvbl90aW1lbGluZV8xMjAzNCI6eyJidWNrZXQiOiJ0cmVhdG1lbnQiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3R3ZWV0X2VkaXRfYmFja2VuZCI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfcmVmc3JjX3Nlc3Npb24iOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYnVzaW5lc3NfdmVyaWZpZWRfYmFkZ2UiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X2NoaW5fcGlsbHNfMTQ3NDEiOnsiYnVja2V0IjoiY29sb3JfaWNvbnMiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3R3ZWV0X3Jlc3VsdF9taWdyYXRpb25fMTM5NzkiOnsiYnVja2V0IjoidHdlZXRfcmVzdWx0IiwidmVyc2lvbiI6bnVsbH0sInRmd19taXhlZF9tZWRpYV8xNTg5NyI6eyJidWNrZXQiOiJ0cmVhdG1lbnQiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3NlbnNpdGl2ZV9tZWRpYV9pbnRlcnN0aXRpYWxfMTM5NjMiOnsiYnVja2V0IjoiaW50ZXJzdGl0aWFsIiwidmVyc2lvbiI6bnVsbH0sInRmd19leHBlcmltZW50c19jb29raWVfZXhwaXJhdGlvbiI6eyJidWNrZXQiOjEyMDk2MDAsInZlcnNpb24iOm51bGx9LCJ0ZndfZHVwbGljYXRlX3NjcmliZXNfdG9fc2V0dGluZ3MiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3ZpZGVvX2hsc19keW5hbWljX21hbmlmZXN0c18xNTA4MiI6eyJidWNrZXQiOiJ0cnVlX2JpdHJhdGUiLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYmx1ZV92ZXJpZmllZF9iYWRnZSI6eyJidWNrZXQiOiJvbiIsInZlcnNpb24iOm51bGx9LCJ0ZndfbGVnYWN5X3RpbWVsaW5lX3N1bnNldCI6eyJidWNrZXQiOnRydWUsInZlcnNpb24iOm51bGx9LCJ0Zndfc2hvd19nb3ZfdmVyaWZpZWRfYmFkZ2UiOnsiYnVja2V0Ijoib24iLCJ2ZXJzaW9uIjpudWxsfSwidGZ3X3Nob3dfYnVzaW5lc3NfYWZmaWxpYXRlX2JhZGdlIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH0sInRmd190d2VldF9lZGl0X2Zyb250ZW5kIjp7ImJ1Y2tldCI6Im9uIiwidmVyc2lvbiI6bnVsbH19&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1603405016525688834&amp;lang=en&amp;origin=https%3A%2F%2Fwww.freecodecamp.org%2Fnews%2Flearn-to-code-book%2F&amp;sessionId=5fb6a17a050a6f4d155b53178392f91afe5602a7&amp;siteScreenName=freecodecamp&amp;theme=light&amp;widgetsVersion=2b959255e8896%3A1673658205745&amp;width=550px" data-tweet-id="1603405016525688834" style="box-sizing: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; font-family: inherit; font-size: 22px; vertical-align: middle; position: static; visibility: visible; width: 550px; height: 708px; display: block; flex-grow: 1;"></iframe>

A video demo of a twitter clone project, built by a freeCodeCamp alumni. This one has no voice-over explanation, and is 2 minutes of UI demo. But it's still really good.

You can can put these project demo videos on websites like YouTube, Twitter, your GitHub profile, and of course your own portfolio website.

For capturing this video, I recommend using QuickTime, which comes built-in with MacOS. And if you're on Windows, you can use Game Recorder, which comes free in Windows 10.

And if you want a more powerful tool, OBS is free and open source. It's harder to learn, but infinitely customizable.

As far as recording tips: keep your font size as large as possible, and use an external mic. Any mic you can find – even from cheap headphones – will be better than speaking into your laptop's built in mic.

Invest as much time as you need to in recording and re-recording takes until you nail it.

Being able to demo your projects and present your code is a valuable skill you'll use throughout your career. Time spent practicing pitching is never wasted.

### How to Start Your Own Open Source Project, Company, or Charity

Being a founder is the fastest – but also riskiest – way to build a reputation as a developer.

It's riskiest because you're wagering your time, your money, and possibly even your personal relationships – all for an unknown outcome.

If you contribute to open source for long enough, you *will* build a reputation as a developer.

If you grind the hackathon circuit for long enough, you *will* build a reputation as a developer*.*

But you could attempt to start entrepreneurial projects for decades without getting traction. And squander your time, money, and connections along the way.

Entrepreneurship is beyond the scope of this book. But if you're interested in it, I will give you this quick advice:

Entrepreneur is a French word that essentially translates to "one who bears risk."

Most entrepreneurs fail. Some fail due to circumstances outside their control. But a lot fail due to not understanding the nature of the risks they're taking on.

Don't rush into founding a project, company, or charity. Try to work for other organizations who are already doing work in your field of interest.

By working for someone else, you get paid to learn. You get exposure to the work, and the risks surrounding it. And you can build savings for an eventual entrepreneurial venture.

## How Not to Destroy Your Reputation

> "It takes a lifetime to build a good reputation, but you can lose it in a minute." – Will Rogers, Actor, Cowboy, and one of my heroes growing up in Oklahoma City

Building your reputation is a marathon, not a sprint.

It may take years to build up a reputation strong enough to open the right doors.

But just like in a competitive marathon, a stumble can cost you valuable time. A stumble that results in injury may put you out of the race completely.

### Don't Say Dumb Things on the Internet

People used to say dumb things all the time. The words might hang in the air for a few minutes while everyone winced. But the words did eventually dissipate.

Now when people say dumb things, they often do so online. And in indelible ink.

Always assume that the moment you type something into a website and press enter, it's going to be saved to a database. That database is going to be backed up across several data centers around the world.

You can prove the existence of data, but there is no way to prove the absence of data.

You should assume, for all intents and purposes, that the cat is out of the bag. There's no getting the cat back in the bag. Whatever you just said: that's on your permanent record.

You can delete the remark. You can delete your account. You can even try to scrub it from Google search results. But someone has probably already backed it up on the Wayback Machine. And when one of those databases inevitably gets hacked years from now, those data will probably still be in there somewhere, ready to resurfaced.

It is a scary time to be a loud mouth. So don't be. Think before you speak.

My advice, which may sound cowardly: get out of the habit of arguing with people online.

Some people abide by the playground rule of "if you don't have something nice to say, don't say anything at all."

I prefer the "praise in public, criticize in private."

I will publicly recognize good work someone is doing in the developer community. If I see a project that impresses me, I will say so.

But I generally refrain from tearing people down. Even people who deserve it.

In a fight, everyone looks dirty.

You don't want to look wrathful, tearing apart someone's argument, or dog piling in on someone who just said something dumb.

Sure – caustic wit can win you internet points in the short term. But it can also make people love you a little bit less and fear you a little bit more.

I also try to refrain from complaining. Yes, I could probably get better customer service if I threatened to tweet about a cancelled flight.

But people are busy. Most of them don't want to use their scarce time, scrolling through social media, only to see me groaning about what is in the grand scheme of things a mild inconvenience.

So that is my advice on using social media. Try to keep it positive.

If it's a matter that you believe strongly about, I won't stop you from speaking your mind. Just think before you type, and think before you hit send.

### Don't Over-promise and Under-deliver

One of the most common ways I see developers torpedo their own reputations is to over-promise and under-deliver. This is not necessarily a fatal error. But it is bad.

Remember when I talked about the Las Vegas hackathon where I utterly failed to finish the project in time for the pitch, and we had to use slides instead of a working app?

Yeah, that was one of the lowest points in my learn to code journey. My teammates were polite, but I'm sure they were disappointed in me. After all, I had been overconfident. I had over-promised what I'd be able to achieve in that time frame, and I had under-delivered.

It is much better to be modest in your estimations of your abilities.

Remember the parable of Icarus, who on wax wings flew too close to the sun. If only he'd taken a more measured approach. Ascended a bit slower. Then his wings wouldn't have melted, and he wouldn't have plunged into the sea, leaving a guilt-stricken father.

![1690px-Pieter_Bruegel_de_Oude_-_De_val_van_Icarus](https://www.freecodecamp.org/news/content/images/2023/01/1690px-Pieter_Bruegel_de_Oude_-_De_val_van_Icarus.jpg)Landscape with the Fall of Icarus by Pieter Bruegel the Elder, circa 1560. Icarus coulda been a contender. He coulda been somebody. But instead, he's just legs disappearing into the sea. And the farmers and the shepherds can't be bothered to look up from their work to take in his insignificance.

### Get Addictions Under Control Before They Damage Your Reputation

If you have an untreated drug, alcohol, or gambling addiction, seek help first. The developer job search can be a long, grueling one. You want to go into it with your full attention.

Even something as seemingly harmless as video game addiction can distract you, and soak up too much of your time. It's worth getting it under control first.

I am not a doctor. And I'm not going to give you a "drugs are bad" speech. But I will say: you may hear of Silicon Valley fads, where developers abuse drugs thinking they can somehow improve their coding or problem solving abilities.

For a while there was a "micro-dosing LSD" trend. There was a pharmaceutical amphetamines trend.

My gut reaction to that is: any edge these may give you is probably unsustainable, and a net negative over a longer time period.

Don't feel peer pressure to take psychoactive drugs. Don't feel peer pressure to drink at happy hours. (I haven't drank so much as a beer since my daughter was born 7 years ago, and I don't feel like I've missed out on anything at all.)

If you are in recovery from addiction, be mindful that learning to code and getting a developer job will be a stressful process. Pace yourself, so you don't risk a relapse.

You do not want to reach the end of the career transition process – and achieve so much – only to have old habits resurface and undo your hard work.

### Try and Separate Your Professional Life From Your Personal Life

You may have heard the expression, "Don't mix business with pleasure."

As a developer, you are going to become a powerful person. You are going to command a certain degree of respect from other people in your city.

Maybe not as much as a doctor or an astronaut. But still. People are going to look up to you.

You are going to talk with people who would love to be in your shoes.

Do not flaunt your wealth.

Do not act as though you're smarter than everybody else.

Do not abuse the power dynamic to get what you want in relationships.

This will make you unlikable to the people around you. And if it's somehow captured and posted online, it may go on to haunt you for the rest of your career.

Never lose sight of how much you have. And how much you have to lose.

### 使用讲述者技巧

在这一章节的最后，让我来分享一个给自己打气的小技巧。

首先，请记住，你是你自己编码之旅中的英雄。 在你的脑海中，每个人都在关注你——他们都支持你。

讲述者技巧是，当你在执行一系列操作时，在脑海中讲述你的动作。

> Quincy 大步穿过黑客空间，他的笔记本电脑夹在胳膊下。 他将马克杯放在热水器下面，然后放入一个新鲜的茶包。 他拉动拉杆。 当热气腾腾的水装满他的杯子时，他用他最好的英国口音大声说道：“茶。 伯爵茶。 热的。”
> 
> 他手里拿着提神饮料，钻进一个隔间，将笔记本电脑平放在桌面上，并瞥见了一位开发者的目光。 他们对视了一会儿。 Quincy 微微地点头，承认了开发者的存在。 开发者也点头回应，仿佛是在心灵感应般地分享着这种情绪：“我看到你了，朋友。 我看到你出现了。 我看到你把事情做好了。”

这可能听起来很荒谬。 当然啦，这是很荒谬的。 但我一直这样做。 而且还很有效。

即使是在脑海中讲述生活中最平凡的时刻，也能帮助你充满活力。 将摆在你面前的时刻具体化，可以使你的目的明确。

而当你以时代为单位思考你的生活时（"塔可钟时代"），这就更有效了。 或者拐点（"通过高考"）。

这与建立你的声誉有什么关系？ 你的声誉本质上是你是谁的总结。 你对周围的人意味着什么。

通过更认真地对待自己，通过把你的生活想象成一部电影，你会逐渐了解你是谁。 以及你有一天想成为的人。

通过讲述你的行为，你可以在自己的脑海中照亮它们。 我为什么要那样做？ 我在想什么？ 在这里有更好的举动吗？

很多人都在不知不觉中破坏了自己的声誉，只是因为他们养成了坏习惯。

多年来，我一直认为我必须一直“有趣”。 我会找任何机会加入一些自嘲的幽默。 很多人意识到我在做什么，觉得很好玩。 但他们中的很多人不明白，只是觉得我是个混蛋。

我为什么要那样做？ 我想这可以追溯到小学，那时我总是想成为班上的小丑，逗别人笑。

但几十年后，这种用笑声来填补沉默的条件反射对我来说并不合适。

> “当你重复地犯一个错误时，它就不再是错误了。 它是一项决定。” – Paulo Coelho

如果我没有注意到这个坏习惯，我可能会坚持更长时间。 但是有了讲述者技巧，我行为的尴尬就暴露无遗了。

我确信我有很多其他的思维方式和行为方式都不是最理想的。 在讲述者技巧的帮助下，我希望将来能够发现它们并加以完善，以免给人留下错误的印象。

### 你的声誉将成为你的传奇。

想想看在你的故事的结尾，你想成为谁。 你希望人们如何看待你在地球上的时间。 然后从那里向后推进。

电影结尾你想成为的那个人。 你希望人们钦佩的那个英雄。 为什么不从现在就开始这样装扮自己呢？

你能想象成为一名成功的开发者会是什么样子吗？ 开发出了人们依赖的软件系统？

那个未来的你——他们会怎么想？ 他们将如何处理情况和解决问题？ 他们会如何谈论他们的成就？ 他们的挫折？

仅仅想一想未来的自己，就能帮助你理清思路。 你的优先事项。

我经常考虑“Quincy 老头”和他不是很好的腰。 他每隔 30 分钟就得借口跑去上厕所。

但 Quincy 老头仍然尽力为自己的事业尽力。 尽管关节酸痛，他还是能动。 尽管头脑一片模糊，他还是在思考。

Quincy 老头还是想把事情做好。 他为自己所取得的成就感到自豪，但他并没有花太多时间回顾过去。 他期待那天他要做什么，以及他要完成什么目标。

我经常想起 Quincy 老头，然后倒回到今天。

我今天可以做出哪些决定，使我明天成为值得钦佩的人？ 我必须等上几十年才能赢得那个声誉吗？ 或者我可以从未来借用一些尊重吗？

通过像我未来的自己那样思考，我可以采取一些行动来为我赢得现在的正面声誉吗？

我相信你现在可以利用你未来的声誉——你的传承。 想想你未来的自己和你将取得的成就。 并将其用作引导你前进的路标。

我希望这些工具——讲述者技巧和想象你未来的自我技巧——不仅能帮助你思考声誉的本质。 我希望它们也能帮助你采取具体步骤来提高你的声誉。

因为建立声誉——让自己名声大噪——是作为开发人员获得可持续成功的最可靠途径。

对很多人来说，成功可能意味着很多事情。 但来自大多数文化的大多数人都会同意：成功的一个重要方面是为自己和家人提供食物。

这就是我们接下来要讨论的内容。

## 第 4 章：如何通过编写代码获得报酬——自由职业客户和求职

如果你一直在培养自己的技能、人脉和声誉，那么获得一份开发人员的工作并没有那么复杂。

请注意，我说的是并不复杂——工作量仍然很大。 并且这可能是一种折磨。

首先，让我告诉你我是如何找到第一份工作的。

### 故事时间：一位 30 多岁的老师是如何获得第一份开发人员工作的？

*上次的故事时间：Quincy 在黑客马拉松赛道上表现出色，甚至赢得了一些赛事。 他正在建立自己作为一名使用 JavaScript 的“危险”开发人员的声誉。 不是超级熟练。 只是危险...*

我刚刚在圣巴巴拉市中心的图书馆结束了漫长的一天学习、喝茶和做项目。

住在加利福尼亚最好的事情就是天气。 我们开玩笑说，当你在郊区租了一套价格过高的单居室公寓时，你不是在为室内买单——你是在为室外买单。

我的目标是尽可能少地呆在那个狭窄的、有 100 年历史的老鼠窝里，利用剩下的时间就在城里四处走走。

那是一个美丽的星期三晚上。 我还有两天时间准备那个周末的黑客马拉松。 我的大脑因为那一天的编码而乱成一团。 我妻子工作到很晚，所以我查看了日历，想找点事做。

在每个月的第一个星期一，我会规划南加州当月即将举行的所有科技活动，所以如果我有精力的话，我总会找到一个我可以参加的科技活动。

啊——今晚是圣巴巴拉 Ruby on Rails 聚会，我已经回复了。

我对 Ruby on Rails 了解不多，但我用它完成了几个小项目。 更多的时候，我是一名 JavaScript 和 Python 开发人员。

但是我想，管他呢。 我需要保持建立人脉的势头。 并且会场就在几个街区之外。

我走进去，只有几个开发人员围坐在桌子旁聊天。 我很快发现，他们都在当地的一家初创公司工作，一起维护着一个庞大的 Ruby on Rails 代码库。 他们中的大多数人已经在那里工作了几年。

在这一点上，我在过去的一年里建立了我的技能、我的人脉和我的声誉。 所以我能够在谈话中保持自己的身份。

但我也意识到自己能力的局限性。 所以我保持谦虚的态度。 低调。 我见过许多其他成功的开发人员在技术活动中操纵对话的方式。

很明显，会议桌上的一位开发人员是工程总监。 他直接向 CTO 汇报。

然后很明显，他们正在寻找 Ruby on Rails 开发人员。

我对自己的背景和能力持坦率态度。 “我的背景是成人教育。 教英语和办学。 我大约一年前才开始学习编码。”

但出乎意料的是，他毫不在意。 “行吧，如果你想过来面试，我们可以看看你是否适合这个团队。”

那天晚上，我走在回家的路上，感觉浑身像是通了电似的。 那是一种恐惧，而不是兴奋。

我觉得还没有准备好。 而且我甚至没有在找工作。 我只是靠积蓄过活，全职学习编码，并通过我妻子的工作获得健康保险。

我是一个强迫性储蓄者。 人们会因此而为难我。 我会自己换机油，自己剪头发，甚至在叫外卖的时候自己在家煮米饭——只是为了省几块钱。

在我当老师的十年间，我成功地存下了将近四分之一的税后收入。 我会在 Craigslist 上购买旧的游戏，然后在 eBay 上出售它们。 这听起来可能很愚蠢，但这对我来说是一个重要的收入来源。

我们存这一切是为了什么？ 我们不确定。 也许将来某个时候在加利福尼亚买房子？ 但这意味着我不必为找工作而忙碌。 我知道我处于一个特权位置，我试图通过每天学习更多来充分利用它。

所以简而言之，我认为我还没有为我的第一份开发人员工作做好准备。 我担心如果他们雇用我，那将是一个大错误。 他们会意识到我是多么缺乏经验，解雇我，然后我必须在以后的工作面试中解释失败的原因。

当然，我现在知道我错误地看待了这个机会。 但是让我把这个故事讲完。

当我申请安排面试的时候，他们找我要简历。 我不知道该怎么做，所以我把我所有的专业经验都写在了那里。 这些年来我工作过的所有学校。 （我故意遗漏了在 Taco Bell 得来速工作的时间。）

当然，我的工作经验都与编码无关。 但我该怎么办，递给他们一张白纸？

好吧，我确实有一个我构建的线上项目组合。 最重要的是，我有一份我赢得或参加的所有黑客马拉松的清单。 所以我包括了那些。

在面试前的最后几个小时，我重温了过去一年中使用过的所有 Ruby on Rails 教程，以刷新记忆。 然后我穿上连帽衫、牛仔裤和背包，走到他们的办公室。

办公室经理是一位和蔼可亲的女士，她带我到开发人员分区，并将我介绍给他们的小型开发团队。 他们大概有十几个人，大多数穿着牛仔裤和连帽衫，年龄从 20 出头到 40 出头。 其中两人是女性。

我轮流在乱七八糟的桌子和电缆中穿行，与他们每个人握手并自我介绍。 这是我作为课堂老师记住学生名字的所有经验都派上用场的地方。 我能够记住他们所有的名字，所以在那天晚些时候当我离开时，我可以跟他们每个人道别：“很高兴见到你，[名字]。 期待能和你一起工作。”

首先我会见了工程总监。 我们走进一间小办公室，关上了门。

墙上的白板上写满了统一建模语言（UML）图的草图。 彩虹般的马克笔列出了各种服务器和服务之间的关系。

我一直盯着那块白板，担心他会派我去解决一些编码问题并展示我的技能。 也许是著名的 fizzbuzz 问题？ 也许他想让我反转二叉树？

但他甚至从未提到过白板。 他只是坐在那里，一直盯着我看。

他们是一家约有 50 名员工的公司，拥有大量风险投资资金和数以千计的付费客户——主要是小企业。 他们以务实为荣。 他们从来没有问过我在学校学的是什么，或者我过去做过什么工作。 他们真正关心的是...

“听着。 我知道你会写代码，”他说。 “你一直在写代码，赢了黑客马拉松。 我检查了你的一些组合项目。 对于刚接触编码的人来说，代码质量还可以。 所以对我来说，真正的问题是——你能了解我们在这里是如何做事的吗？ 你能和团队中的其他开发人员一起工作吗？ 最关键的是：你能把事情做好吗？”

我咽了咽口水，身体前倾，尽我所能地鼓起信心。 “可以，”我说。 “我相信我可以。”

他说：“很好。 很好。 可以。 去楼下的越南米粉餐厅等着。 [CTO 的名字] 应该马上就过去。”

于是和 CTO 边吃边聊。 主要是听。 我了解到人们会将智慧投射到安静的人身上。 专心聆听不仅可以帮助你变得更聪明，甚至可以让你看起来更聪明。

这种方法奏效了。 会议持续了大约一个小时。 米粉很好吃。 我学到了很多关于公司历史和近期目标的知识。 CTO 说，“好的，回去和 [工程总监] 谈谈。”

我也这样做了。 然后他给了我一份工作。

现在，我要强调。 这不是大多数人获得第一份开发人员工作的方式。

你可能在想，“哎呀，Quincy 只是随便做做，就得到了他甚至都没有寻找过的开发人员工作。 要是我们都能这么幸运就好了”

这当然就是我当时的感觉。 但在下一节中，我将探讨雇主与开发者之间的关系。 我如何找到那份工作，与其说是我作为面试者的技能，不如说是之前一年的编码、人脉和声誉建设的成果。

这不是一份轻松的工作，在一家大型的科技公司，有着丰厚的薪酬、福利和公司保龄球馆。 这是一个合同工的角色，薪水与我作为老师的薪水大致相同。

但这是一项开发工作。 一家公司付钱让我写代码。

我现在是一名专业的开发人员了。

### 雇主想要什么

转眼间十年过去了。 我现在已经在桌子的两边都坐过了。 我作为开发者接受过招聘经理的面试。 我也以招聘经理的身份面试过开发人员。

我花了很多时间与正在找工作的开发人员通电话。 他们中的一些人已经申请了数百份工作，但只收到了几次面试的“回电”。

我还花了很多时间与经理和招聘人员通电话，试图更好地了解他们如何招聘以及他们在寻找什么。

我认为开发人员对招聘过程感到沮丧的大部分原因，都归结为误解。

雇主最看重一件事：可预测性。

你认为雇主会喜欢哪位候选人？

**X** 是拥有十倍效率的“摇滚明星”天才程序员。 X 还具有令人难以置信的生产力。 但 X 经常对同事脾气暴躁，还经常错过最后期限或会议。

**Y** 是一个不错的程序员，输出速度较慢但更始终如一。 Y 与同事相处融洽，很少错过会议或截止日期。

**Z** 在输出上与 Y 相似，能够与同事和睦相处，按时完成任务。 但是 Z 在过去 3 年里换了 3 次工作。

好吧，你可能会从我到目前为止所说的一切中猜到：**Y** 是首选候选者。 这是因为雇主最看重可预测性。

**X** 是一些新任经理可能会在招聘时犯的错误的陷阱候选人。 如果你好奇为什么雇用 X 会是一个糟糕的主意，请阅读 [我们解雇了我们的顶尖人才。 我们做出的最佳决定。](https://www.freecodecamp.org/news/we-fired-our-top-talent-best-decision-we-ever-made-4c0a99728fde/)

我将 **Z** 添加到此列表只是为了说明一个观点：尽量不要过于频繁地更换工作。

你可以通过从雇主到雇主的阶梯式跳跃快速增加收入。 接受录用通知后，你就可以开始申请新工作。 但这会遭到许多招聘经理的排斥。

毕竟滚石不生苔。 你会进入然后退出代码库，还没来得及了解它们的工作原理。

考虑一下：经理可能需要 6 个月或更长时间才能让新开发人员跟上速度，让他们可以为团队带来正向收入。

在那之前，新员工本质上是在消耗公司资源，从同事那里吸收时间和精力，而同事必须让他们入职，帮助他们找到解决代码库的方法，并修复他们的错误。

### 大多数雇主都厌恶风险

假设一个经理雇用了错误的开发者。 花点时间想象一下，这对团队来说会有多糟糕。

平均而言，填补一家公司的开发人员职位需要大约 3 个月的时间。 雇主必须首先：

- 获得预算，来雇佣一个已经被老板批准的开发人员
- 编写职位描述
- 在求职网站上发布职位并与招聘人员沟通
- 筛选简历——其中许多都是盲目申请尽可能多的工作的求职者的低成本努力
- 开始面试过程，这可能涉及让候选人飞到当前城市并住在酒店
- 涉及许多其他团队成员的多轮面试。 对于一些雇主来说，这是一个为期数天的事情
- 选择最终候选人，并谈判报价......
- 许多候选人无论如何都不会接受
- 签订合同和帮员工入职
- 给与让他们访问敏感的内部系统的权限
- 将他们介绍给他们的队友，并确保每个人都相处得很好
- 然后是几个月的非正式培训，让员工了解一项服务或遗留代码库的一部分
- 让他们沉浸在团队的做事方式中

简而言之——大量的工作。

现在想象一下，在完成所有这些之后，新员工说：“嘿，我刚刚从另一家公司得到了更高的薪资。 拜拜了，您嘞。”

或者想象该员工并不可靠，经常在工作开始后几个小时才出现。

再想象一下，该员工与未经许可的药物、酒精或赌博成瘾、愤怒问题作斗争——或者只是被发现是一个争强好斗、破坏团队的人。

现在你必须重新开始整个过程，并为该职位寻找新的候选人。

招聘是很难的。

所以你可以明白为什么雇主厌恶风险。 他们中的许多人会忽略看似合格的候选人，直到找到他们认为有 99% 把握的人。

### 因为雇主非常厌恶风险，所以求职者受苦

如果你现在认为招聘很困难，你一定不知道工作申请流程有多复杂。你或许已经对它再熟悉不过了。就像这样……

- 你必须准备简历。同时，你将在整个求职过程中不断地摸索着做决定。
- 你必须在网上四处寻找职位空缺，研究雇主，并且评估他们是否适合你。
- 大多数职位的申请都需要填表，你将不得不一遍又一遍地重新填写简历，希望表单不会因服务器错误或 JavaScript 验证错误而崩溃。
- 提交这些工作申请后，你必须等待雇主处理它们。有一些雇主并不会人工审阅所有申请，因为他们收到的申请实在太多了。（比如谷歌每天能收到 9000 份申请。）雇主会使用软件来筛选。内部招聘人员 [平均只花6秒查看每份简历](https://www.freecodecamp.org/news/you-in-6-seconds-how-to-write-a-resume-that-employers-will-actually-read-fd7757740802/)。通常你的申请甚至永远不会被人工审阅。
- 你可能永远不会收到公司的任何回复。他们几乎没有动机告诉你他们为什么拒绝你（他们不希望你提起歧视诉讼）。如果你幸运的话，你会收到一封“我们已经决定选择其他候选人”的电子邮件。
- 所有你花在申请这些工作上的时间——可能是每周几个小时——是消耗精力的，当然，也是无偿的。

是吧。所以你可以看到招聘过程对雇主，尤其对求职者来说都是一场噩梦。

但如果你坚持下去，你最终可以拿到一些 offer。毕竟好运也是连着来的。

以下是一位 freeCodeCamp 贡献者在12周内的求职数据：

![85L921BMzXxKhVySPo9gxWamr5J4QLFJaVEn](https://www.freecodecamp.org/news/content/images/2023/01/85L921BMzXxKhVySPo9gxWamr5J4QLFJaVEn.png)

在投递了291份申请之后，他最终收到了8个 offer。

随着 offer 的陆续到来，起薪也越来越高。当然，请注意，这是在世界上消费水平最高的城市之一——旧金山的工作。

![bDp3eVv6VQS3Og3ulVpwp6dDylIybdpRczsD](https://www.freecodecamp.org/news/content/images/2023/01/bDp3eVv6VQS3Og3ulVpwp6dDylIybdpRczsD.png)

到第12周时，在他收到的 offer 里，起薪几乎是第2周的两倍。

这位开发者得到面试的几率相当高。而且他的谈判能力也很强。如果你感兴趣，可以[在这里](https://www.freecodecamp.org/news/5-key-learnings-from-the-post-bootcamp-job-search-9a07468d2331/)了解更多关于他求职过程的内容。

但正如我之前所说，其实从“旁门”进入一家公司会更容易一些。

这就是我写这本书的原因之一。我不希望你们都在雇主的“前门”排队。

### 如果你建立了自己的技能、人脉和声誉，你就可以绕过很多工作申请流程。

在本书中，我一直在教你一些增加“走运”获得工作机会可能性的技巧。

> “运气是准备遇见机会。如果你在机会来临时没有做好准备，你就不会'幸运'。” —— 奥普拉·温弗瑞

这就是为什么在整本书中我都鼓励你同时发展这三个领域，并且从第一天起就开始考虑它们——在你找工作之前。

我没有特意找工作但却找到了工作的故事可能看起来有点蠢。但这种情况发生的频率可能比你想象的要高。

现实是：学习编程很困难。

但是知道如何编程很重要。

在每个行业中——几乎在世界上的每个公司中——管理者们都在试图找到将他们的流程软件化的方法。

这就意味着需要开发人员。

你可能听说过科技行业偶尔会出现大规模裁员。 但是，如果你缩小并查看更长的时间线，开发人员的招聘趋势无疑是增长的。

我希望凭借优秀的技能、强大的人脉和良好的声誉，你将额外耗费最少的精力并找到一份好工作。

希望在我们有生之年的某一天，雇主和有技能的员工可以更容易地找到彼此，而无需漫长、残酷的工作申请和面试过程。

### 我应该在第一份开发工作谈判薪资吗？

只要你礼貌地进行谈判沟通，尝试提高你的薪水通常不会有什么坏处。

我写过一篇更详细的关于[如何进行开发工作的薪资谈判](https://www.freecodecamp.org/news/salary-negotiation-how-not-to-set-a-bunch-of-money-on-fire-605aabbaf84b/)的文章。

从本质上讲，谈判更高的起薪取决于你有多少能力。

你的雇主有工作要完成。他们有多需要你来为他们工作？他们还有什么其他选择？

而你需要收入来生活。你有什么其他的选择？你的备选计划是什么？

如果你有另一家雇主提供的工作机会，并且愿意支付某个金额的薪水，你可以将其作为谈判薪资的筹码。

如果你的最佳后备计划是回到学校并获得研究生学位……那不算特别强大的筹码，但总比没有好。你可以在薪资谈判的过程中提到它。

回想一下我之前描述的漫长的招聘过程。雇主必须经过至少十几个步骤才能与候选人到达将要发放 offer 的那一步。他们可能已经预料到你会进行薪资谈判，并不会对此感到惊讶。

现在，如果你和我一样，有家公司突然给你一份工作，你可能会觉得谈判薪资很尴尬。

![92508](https://www.freecodecamp.org/news/content/images/2023/01/92508.jpeg)

《辛普森一家》里的史密瑟斯

我承认——在我上面写的故事里，当我的经理给我这份工作时，我没有谈判。

回想起来，我本应该协商我的报酬吗？也许吧。

我有什么筹码吗？可能不多。我的备选计划是继续参加编程比赛，在公共图书馆喝茶和写代码。

我也许能去谈判并每小时多赚几美元。但在他们给我那份工作的那一刻，报酬是我最后才考虑到的事情。我只是欣喜若狂，因为我即将成为一名专业的开发人员。

顺便说一句，一旦你在一家公司担任开发人员一年左右，你可能会想要求加薪。我已经写了更详细的关于[作为开发人员如何要求加薪](https://www.freecodecamp.org/news/youre-underpaid-here-s-how-you-can-get-the-pay-raise-you-deserve-fafcf52956d6/)的文章。但归根结底都是同一件事：谈判筹码。

### 你应该找猎头帮忙搜寻开发职位吗？

是的。如果你能找到一位猎头来帮助你找到第一份开发工作，那么你应该这样做。

我已经写过关于[为什么猎头是你找工作时被低估的工具](https://www.freecodecamp.org/news/the-tech-recruiter-red-pill-967dd492560c/)的文章。

许多雇主会向猎头支付中介费，用以向他们输送高质量的求职者。

猎头的目标和奖励机制与作为求职者的你完全一致：

1. 他们将根据你的起薪获得报酬，因此他们倾向于帮助你协商到尽可能高的起薪。
2. 他们成功输送的候选人越多——输送的速度越快——他们赚的钱就越多。所以他们会希望帮助你尽快找到工作，这样他们就可以转向其他求职者。
3. 因为他们只有在你成为一名正式员工（并且至少待90天）后才会得到报酬，所以他们会努力确保你能胜任这份工作，并且适合公司的文化。

话说回来，如果猎头要求你为任何事情付钱给他们，那就是危险信号。

并不是所有的猎头都是相同的。在与猎头合作之前先做个调查。即使他们最终得到了雇主的报酬，你仍然在花时间帮助他们的工作。时间是很宝贵的。

说到时间，有一种可以让你更快达到写代码获得报酬的方法——即便你还在为求职做准备——做一些自由开发者的工作。

### 如何找到自由客户

我鼓励初级开发人员在开始找工作之前尝试获得一些自由客户。这里有三个很好的理由：

1. 获得自由客户比找到全职工作要容易得多。
2. 自由职业的风险较小，因为你可以在不辞去日常工作的情况下进行。
3. 你可以更快地开始通过写代码获得报酬，并更快地开始构建你的专业作品集。

获得自由客户比找到开发工作要容易得多。这是为什么？

想想当地的小型企业。它可能只是一个经营餐馆、商店、管道公司或者律师事务所的家庭。

这些企业中有多少可以从交互式网站、后台管理系统和工具中受益，以自动化他们的日常工作流程呢？答案当然是他们中的大多数。

然而这些公司中有多少能够聘请全职软件开发人员来构建和维护这些系统呢？没有那么多。

这就是自由职业者的用武之地。使用他们更加经济实惠。小型企业可以为单个项目或短期聘请自由职业者。

如果你正在积极建立你的人脉，你遇到的一些人可能会成为你的客户。

例如，你可能会遇到一位想要更新其网站的本地会计师，他可能想添加安排咨询或接受信用卡支付的能力。这些是小型企业可能要求的常见功能，你可能会非常擅长实现它们。

你可能还会遇到需要 ERP 系统、CRM 系统、库存系统或无数其他工具之一的小型企业的管理者。

在许多情况下，你可以为他们部署和配置一个开源工具。然后你可以教他们如何使用那个系统。你可以按月向他们收取服务费，让你“随叫随到”并准备好解决可能出现的问题。

### 我应该签订自由职业合同吗？

你需要找到一个标准的合同模板，修改它，然后请律师批准。

让当地的面包店与你签订合同只是为了帮助更新他们的网站或社交媒体形象，这可能会让人感到尴尬。但这样做会让整个交易比单纯的握手协议更专业。

一家小企业不太可能会因为几千美元而将你告上法庭。但如果发生这种情况，你会很高兴自己签了合同。

### 我应该为自由职业的工作收取多少费用？

我会计算出你日常工作的时薪，然后加倍。这听起来可能是很多钱，但自由职业比常规工作要难得多。你必须学习很多东西。

或者，你可以以单个项目为单位计费。 “我将以1000美元的价格为你部署和配置此系统。”

请务必指定你愿意维护项目的时间范围。你不希望人们在3年后打电话给你，希望你回来修复一个没有人维护的系统。

### 我如何确保自由客户会付钱给我？

很多其他的自由职业者——包括我自己——都使用这种简单的方法：在开始工作之前预先索取一半的报酬。当你能证明你已经完成了一半时，就要求他们支付另一半。

尽量在你真正完成项目之前拿到所有报酬，这样，客户就无法用未支付的报酬来试图让你做额外的工作。

如果你已经得到全额报酬，那么你之后为客户所做的工作将传达这个意思：“我为你付出了更多。”

这带来了一种完全不同的气氛：“啊哦——你会为我做的所有工作付钱给我吗？”

### 我应该使用像 Upwork 或者 Fiverr 这样的自由职业网站吗？

如果你在一些偏远地区并且在当地找不到任何客户，你可以尝试其中的一些自由职业网站。但除此之外，我不会关注它们。原因如下：

当你尝试在自由职业网站上找兼职工作时，你是在与世界各地的所有自由职业者竞争。他们中的许多人居住在生活成本比你低得多的城市。他们中的一些人甚至不会像你一样真正关心自己的声誉，并且可能愿意接受低于标准报酬的工作。

在某种程度上，这些网站助长了一种“逐底竞争”现象，即提供最廉价劳动力的人通常会得到这份工作。

如果你转而专注于通过自己的本地人际关系寻找客户，你将不必与这些国外的自由职业者竞争。

需要寻求自由开发者帮助的人也是如此。 如果你想雇用一名自由职业者，我强烈建议你与可以见到面的人一起工作，他与你的社区有联系。

在你的城市生活了几年，并且与你有很多交集的人——他们不太可能试图占你的便宜。如果你和你的合作方都关心自己的声誉，那么你们会成就一段有效的合作伙伴关系。

你们会可以成为对方履历中的成功故事。

### 我什么时候应该停止自由职业并开始找正式工作？

如果你有能力以自由职业维生，你可能只想继续做下去。慢慢地，你甚至可以建立自己的软件开发机构，并聘请其他开发人员来帮助你。

话说回来，如果你渴望拥有稳定的开发工作，那么你可能很走运。如果你坚持足够长的时间，自由客户可能会给你全职工作。在某些时候，客户以较低的时薪给你提供一份全职工作可能更经济实惠。你得到一份稳定的每周工作40小时的工作，而他们全职获得你的技能。

当你找到工作时，你也可以保留一些自由客户。这是很好的收入补贴。但请记住，正如我们将在下一章中了解到的那样，你的第一份开发工作可能会需要你非常尽职尽责。至少在一开始的时候是这样。

成为职业开发者的第一年会有多疯狂呢？让我们来谈谈这个。

## 第5章：如何在你的第一份开发工作中取得成功

> "待在港口的船很安全。但这不是造船的目的。" —— 格蕾丝·霍珀，数学家，美国海军少将，计算机科学先驱

一旦你获得第一份开发工作，那就是真正学习的开始。

你将学习如何与其他开发人员一起高效工作。

你将学习如何浏览大型遗留代码库。

你将学习版本控制系统、持续集成和持续交付工具 (CI/CD)、项目管理工具等。

你将学习如何在技术管理者手下工作。如何在截止日期前交付。以及如何解决工作中的大量分歧。

最重要的是，你将学会如何管理自己。

你将学习如何突破影响我们所有人的心理障碍，例如冒名顶替综合症。你将了解到自己的极限，以及如何稍微地超越它们。

### 讲故事时间：一名30多岁的教师如何在他的第一份开发工作中取得成功？

*上一次故事时间回顾：昆西在当地一家科技初创公司找到了他的第一份开发工作。他将成为维护一个庞大、复杂的代码库的十几名开发人员中的一员。他不知道自己在做什么……*

我凌晨4点醒来，再也睡不着了。我努力尝试睡着。但是我的胸口像在燃烧一样。焦虑和恐慌包围了我。

我在教育领域工作了十年。先当家教。然后当老师。接着担任校长。

几个小时后，我将从头开始，成为一名开发人员。

我过去的任何学习——过去的成功——对我的新职业来说有什么意义吗？

我做了我感到焦虑时最常做的事——跑步。我跑下山坡，头灯在黑暗中摇晃。当我到达海滩时，太阳慢慢爬上树梢，我沿着大海奔跑。

当我回到家时，我妻子已经出门上班了。她告诉我不要担心。她说，“即使你因为不知道自己在做什么而被解雇，我依然爱你。”

当我到达我的新办公室时，那里没有人。作为一名教师，我习惯于7点30分准时到校。但我很快意识到，大多数软件开发人员并没有那么早开始工作。

所以我盘腿坐在入口走廊上，按照上网本上的教程写代码。

一名员工朝我走来，脸上带着紧张的表情。她可能认为我是一个来占位的闲杂人等。我向她保证我确实在她的公司工作，并说服她让我进去。

穿过空荡荡的开放式办公室走向开发人员工作的区域，我感觉像在做梦，只有出口标志的灯光指引着我的路。

我在一张空的站立式办公桌上设置了我的上网本，并完成了编码教程。

过了一会儿，我周围的灯光亮了起来。我的老板来了。起初他并没在意我的存在。他只是在办公桌前坐下，开始敲击他的机械键盘。

“拉尔森，”他终于开口了。“你准备好迎接你这个重要的第一天了吗？”

我还没准备好。但我想表现出我的信心。所以我说了我最喜欢的 80 年代电影之一《妖魔大闹唐人街》中的第一句台词：“我生来就准备好了。”

![big-trubs-born-ready](https://www.freecodecamp.org/news/content/images/2023/01/big-trubs-born-ready.jpeg)

你可能已经听过上百万次“我天生就准备好了”。但这句话最早是在 1986 年杰克·伯顿 (Jack Burton) 对他的朋友王驰 (Wang Chi) 说的，当时他们正准备在他的死亡仓库中与一位千年老巫师对峙。 我不敢相信我的父母当时让我看这个，但我很高兴他们这么做了。

“好极了，”我的老板说。“那么先给你配一台电脑。”

“哦，我已经有了一个，”我敲了敲我200美元的上网本说。“这个宝贝正在运行 Linux Mint，我已经自定义了我的 .emacs 文件，以便能够……”

“我们是一家 Mac 商店，”他说着走向储藏室。他搜寻了一会儿，然后出现了。“这是一个已经用了3年的模型，但它应该还够用。我们把它重置到出厂设置。”

我开始说我已经熟悉我的电脑配置，而且我用它能更快地工作，但他并不接受。

“我们都在使用相同的工具。它使协作变得更加容易。你要知道，惯例优于配置。”

那是我第一次听到“惯例优于配置”这个词，但在接下来的几天里它会出现很多次。

其他开发人员陆续到了公司，而我花了接下来的几个小时来配置我的新电脑。

接近上午10点时，我们开始了团队“站会”。我们站在白板前围成一圈，轮流汇报当天的工作。

每个人都提供简洁、准确的进展更新。

轮到我了，我开始自我介绍。当时我已经非常紧张了，结果这时候迈克走了进来，他是超级马拉松运动员，也主持举办圣塔芭芭拉的初创企业活动。他正在吃一些小胡萝卜，那天早上他已经跑了大约30英里。

在我结束后，迈克说话了，欢迎了我并且说他在一些活动中见过我。然后，他用15秒的时间讲述了有关他正在写一些功能的工作。

整个会议只进行了大约10分钟，大家就各自回到了自己的办公桌。

我最终让公司的代码库在我的新笔记本电脑上运行。这是一个已经发展了5年多的 Ruby on Rails 应用程序。我运行了“rake stats”命令，发现它有数百万行代码。我不寒而栗。我怎么可能能理解这些东西呢？

我的隔壁桌，一个看起来粗鲁的、留着胡子的开发人员说，“嗯，其中大部分只是包。你实际要处理的代码库可能只有100000行。别担心。你会掌握它的窍门的。”

我咽了咽口水，心想：“这还不到一百万呢，还行。”

“顺便说一句，我叫尼克，”他自我介绍道。 “如果你需要任何帮助，请告诉我。我已经在这个代码库上摸索了好几年，所以我应该可以帮到你。”

在接下来的几天里，我向尼克提问了每一个我遇到的内部系统问题。

Eventually Nick started setting his chat status to "code mode" and putting on his noise cancelling headphones. He swiveled his back toward me a bit, with the body language of: "leave me alone so I can get some of my own work done, too."

This was one of my earliest lessons about team dynamics. You don't want to wear out your welcome with too many questions. You need to get better at learning things for yourself.

But this was a massive codebase, and it was largely undocumented, aside from inline comments and a pretty sparse team wiki.

Since it was a close-source codebase that only the devs around me were working in, I couldn't use Stack Overflow to figure out where particular logic was located. I just had to feel around in the dark.

I started rotating through which neighbor I'd bug about a particular question. But it felt like I was quickly ringing out any enthusiasm they may have had left for me as a teammate.

I over-corrected. I became shy about asking even simple questions. I made a rule for myself that I would try for 2 hours to get unstuck before I would ask for help.

At some point, after thrashing for several hours, I did ask for help. When my manager discovered I'd been stuck all morning, he asked, "Why didn't you ask for help earlier?"

Another struggle was with understanding the codebase itself – the "monolith" and its many microservices.

The codebase had thousands unit tests and integration tests. Whenever you wrote a new code contribution, you were also supposed to write tests. These tests helped ensure that your code did what it was supposed to – and didn't break any existing functionality.

I would frequently "break the build" by committing code that I thought was sufficiently tested – only to have my code break some other part of the app I hadn't thought about. This frustrated the entire team, who were unable to merge their own code until the root problem had been fixed.

The build would break several times a week. And I was not the only person who made these sorts of mistakes. But it **felt** like I was.

There were days where I felt like I was not cut out to be a developer. I'd say to myself: "Who am I kidding? I just wake up one day and decide I'm going to be a developer?"

I kept hearing echoes of all those things my developer friends had said to me a year earlier, when I was first starting my coding journey.

"How are you going to hang with people who grew up coding from an early age?"

"Why don't you just stick with what you're good at?"

"You're going to have to drink an entire ocean of knowledge."

I would take progressively longer breaks to get away from my computer. The office had a kitchen filled with snacks. I would find more excuses to get up to grab a snack. Anything to delay the crushing sense that I had no idea what I was doing.

The first few months were rough. During morning standup meetings, it felt like everyone was moving fast. Closing open bugs and shipping features. It felt like I had nothing to say. I was still working on the same feature as the day before.

Every day when I woke up and got ready for work, I felt dread. "This is going to be the day they fire me."

But then I'd go to work and everyone would be pretty kind, pretty patient. I would ask for help if I was really stuck. I would make **some** progress, and maybe fix a bug or two.

I was getting faster at navigating the codebase. I was getting faster at reading stack traces when my code errored out. I was shipping features at a faster clip than before.

Whenever my boss called me into his office, I would think to myself: "Oh no, I was right. I'm going to get fired today." But he would just assign me some more bugs to fix, or features to develop. Phew.

It was the most surreal thing – me terrified out of my mind that I'm about to get the axe, and him having no idea anything's wrong.

Of course, I had heard the term "imposter syndrome" before. But I didn't realize that was what I was experiencing. Surely I was just suffering from "sucks at coding" syndrome, right?

One day I was sitting next to Nick, and he was looking pretty frazzled. I offered to grab him a soda from the kitchen.

When I got back, he cracked the can open, took a sip, and leaned back in his chair, gazing at his monitor full of code. "This bug, man. Three weeks trying to fix this one bug. At this point I'm debugging it in my sleep."

"Three weeks trying to fix the same bug?" I asked. I had never heard of such a thing.

"Some bugs are tougher to crack than others. This is one of those really devious ones."

It felt like someone had slapped me across the face with a salmon. I had viewed my job as chunks of work. As though it should take half a day to fix a bug, and if it took longer than that, I was doing something wrong.

But here Nick was – with his computer science degree from University of California and his years of experience working on this same codebase – and he was stumped for three weeks on a single bug.

Maybe I had been too hard on myself. Maybe some of these bugs I'd been fixing were not necessarily "half day bugs", but were "two or three day bugs." Yes, I was inexperienced and slow. But even so, maybe I was holding myself to unrealistic standards.

After all, when we budgeted time for features, sometimes we would have "5-day features" or even "2-week features." We didn't do this for bugs, but they probably varied similarly.

I went home and read more about Imposter Syndrome. And what I read explained away a lot of my anxiety.

Over the coming months, I kept building out features for the codebase. I kept collaborating with my team. It was still hard, brain-busting work. But it was starting to get a little bit easier.

I bonded with my teammates each day at lunch over board games. One week, we had a company-wide chess tournament.

A couple rounds in, I played against the CEO.

The CEO has an unorthodox chess play style. He used a silly opening that few serious chess players would opt for. And I was able to take any early lead in the game.

But over the next few moves, he was able to slowly grind back control over the game. He eventually gained the upper hand and beat me.

When I asked him how he found time to keep his chess skills sharp while running a company, he said, "Oh, I don't. I only play once or twice a year."

He paused for a moment, his hand frozen in front of him, as if preparing to launch into a lecture. He said: "My uncle was a competitive chess player. And he just gave me a single piece of advice to follow: **every time your opponent moves, slow down and try to understand the game from their perspective – why did they make that move?**"

He bowed then excused himself to run to a meeting.

I've thought a lot about what he said over the years. And I've realized this advice doesn't just apply to chess. You can apply it to any adversarial situation.

### If You Keep Having to Do a Task, You Should Probably Automate it

Another lesson I learned about software development: since I was the most junior person on the team, I often got assigned the "grunt work" that nobody else wanted to do. One of these tasks was to be the "build nanny."

Whenever someone broke the build, I would pull down the latest version of our main branch and use `git bisect` to try and identify the commit that broke it.

I'd open up that commit, run the tests, and figure out what went wrong. Then I'd send a message to the person who broke the build, telling them what they needed to fix.

I got really fast at doing this. In a day full of confusing bug reports and ambiguous feature requests, I looked forward to the build breaking. It would give me a chance to feel useful real quick.

It wasn't long before someone on the team said, "With how often the build breaks, we should just automate this."

I didn't say anything, but I felt defensive. This was a bad idea. How could a script do as good a job at finding the guilty commit as I – a flesh and blood developer – could?

It took a few days. But sure enough, one of my teammates whipped up a script. And I didn't have to be the build nanny anymore.

It felt strange to see a message that the build failed, and then a moment later see a message saying which commit broke the build and who needed to go fix it.

I felt indignant. I didn't say anything, but in my mind I was thinking: "That's supposed to be my work. That script took my job."

But of course, I now look back at my reaction and laugh. I imagine myself, now in my 40s, still dropping everything several times each week so I could be the build nanny.

Because in practice, if a task can be automated – if you can break it down into discrete steps that a computer can reliably do for you – then you should probably automate it.

There's plenty of more interesting work you can do with your time.

![is_it_worth_the_time_2x-1](https://www.freecodecamp.org/news/content/images/2023/01/is_it_worth_the_time_2x-1.png)This chart from XKCD shows can help you figure out whether a task is worth the time investment to automate.

### Lessons from the Village Elders

I learned a lot from other people on the team. I learned product design concepts from Mike. He took me running on the beach, and taught me how to run on my forefoot, where the balls of my feet hit the ground before my heels. This is a bit easier on your joints.

And I learned about agile software engineering concepts from Nick. He helped me pick out some good software development books from the library. And he even invited me over for a house-warming party, and I got to meet his kids.

After about a year of working for the company, I felt it was time to try to strike out on my own, and build some projects around online learning. I sat down with the CTO to break the news to him that I was leaving.

I said, "I'm grateful that you all hired me, even though I was clearly the weakest developer at the company."

He let out a laugh and said, "Sure, when you started, you were the worst developer on the team. I'd say you're still the worst developer on the team."

I sat there smiling awkwardly, blinking at him, not sure whether he was just angry I was leaving.

And then he said, "But that's smart. You're smart. Because **you always want to be the worst musician in the band**. You always want to be surrounded by people who are better than you. That's how you grow."

Two weeks later, I checked in my code changes for the day and handed off my open tickets. I reset my Mac to factory settings and handed it to my manager.

I shook hands with my teammates and headed out the door into the California evening air.

I hit the ground running, lining up freelance contracts to keep the lights on. And I scouted out an apartment in Oakland, just across the bridge from the beating heart of tech in South of Market San Francisco.

I was now a professional developer with a year of experience already under my belt.

I was ready to dream new dreams and make new moves.

I was off to the land of startups.

### Lessons From my First Year as a Developer

I did a lot of things right during my first year as a professional developer. I give myself a B-.

But if I had the chance to do it all again, there are some things I'd do differently.

Here are some tips. May these maximize your learning and minimize your heartache.

#### Leave Your Ego at the Door

Many people entering the software development field will start at the very bottom. One title you might have is "Junior Developer."

It can feel a bit awkward to be middle aged and have the word "junior" in your title. But with some patience and some hard work, you can move past it.

One problem I faced every day was – I had 10 years of professional experience. I was not an entry level employee. Yes, I was new to development, but I was quite experienced at teaching and even managing people. (I'd managed 30 employees at my most recent teaching job.)

And yet – in spite of all my past work experience – I was still an entry level developer. I was still a novice. A neophyte. A newbie.

As much as I wanted to scream "I used to be the boss – I don't need you to babysit me" – the truth was I did need babysitters.

What if I accidentally broke production? What if I introduced a security vulnerability into the app? What if I wiped the entire database? Or encrypted something important and lost the key?

These sorts of disasters happen all the time. And it's not just new developers who make these mistakes.

The reality is as a new developer, you are like a bull in a China shop, trying to walk carefully, but smashing everything in your path.

Don't let yourself get impatient with your teammates. Resist the temptation to talk about your advanced degrees, awards your work has won, or that time the mayor gave you the key to the city. (OK, maybe that last one never happened to me.)

Not just because it will make you hard to work with. Because it will distract you from the task at hand.

For the first few months of my developer career, I used my past accomplishments as a sort of pacifier. "Yeah I suck at coding, but I'm phenomenal at teaching English grammar. Did I mention I used to run a school?"

When your fingers are on the keyboard, and your eyes are on the code editor, you have to let that past self go. You can revel in yesterday's accomplishment tonight, after today's work is done.

But for now, you need to accept all the emotions that come with being a beginner again. You need to focus on the task at hand and get the job done.

### It's Probably Just the Imposter Syndrome Talking

Almost everyone I know has experienced Imposter Syndrome. That feeling that you do not belong. That feeling that at any moment your teammates are going to see how terrible your code is and expose you as not a "real developer."

To some extent, the feeling does not go away. It's always there in the back of your mind, ready to rear its head when you try to do something new.

"Could you help me get past this error message?" "Um... I'm not sure if I'm the best person to ask."

"Could you pair program with me on implementing this feature?" "Um... I guess if you can't find someone more qualified."

"Could you give a talk at our upcoming conference?" "Um... me?"

I've met senior engineers who still suffer from occasional imposter syndrome, more than a decade into their career.

When you feel inadequate or unprepared, it may just be imposter syndrome.

Sure – if you handed me a scalpel and said, "help me perform heart surgery" I would feel like an imposter. To some extent, feeling out of your depth is totally reasonable if you are indeed out of your depth.

The problem is that if you've been practicing software development, you may be able to do something but still inexplicably suffer from anxiety.

I am not a doctor. But my instinct is that – for most people – imposter syndrome will gradually diminish with time, as you get more practice and build more confidence.

But it can randomly pop up. I'm not afraid to admit that I sometimes feel pangs of imposter syndrome when doing a new task, or one I haven't done in a while.

The key is to just accept it: "It's probably just the imposter syndrome talking."

And to keep going.

### Find Your Tribe. But Don't Fall for Tribalism

When you get your first developer job, you'll work alongside other developers. Yipee – you found your tribe.

You'll spend a lot of time with them, and you all may start to feel like a tight unit.

But don't ignore the non-developer people around you.

In my story above, I talked about Mike, the Product Manager who also ran startup events. He was "non-technical". His knowledge of coding was limited at best. But I'd venture to say I learned as much from him as anyone else at the company.

You may work with other people from other departments – designers, product managers, project managers, IT people, QA people, marketers, even finance and accounting folks. You can learn a lot from these people, too.

Yes, you should focus on building strong connective tissue between you and the other devs on the team. But stay curious. Hang out with other people in the lunch room or at company events. You never know who's going to be the next person to help you build your skills, your network, or your reputation.

### Don't Get Too Comfortable and Specialize too Early

I often give this advice to folks who are first starting their coding journey: "learn general coding skills (JavaScript, SQL, Linux, and so on) and then specialize on the job."

The idea is, once you understand how the most common tools work, you can learn those tools' less common equivalents.

For example, once you've learned PostgreSQL, you can easily learn MySQL. Once you've learned Node.js, you can easily learn Ruby on Rails or Java Spring Boot.

But some people specialize too early at work. Their boss might ask them to "own" a certain API or feature. And if they do a good job with that, their boss may keep giving them similar projects.

You are only managing yourself, but your boss is managing many people. They may be too busy to develop a nuanced understanding of your abilities and interests. They may come to see you as "the XYZ person" and just give you tasks related to that.

But you know what you're good at, and what you're interested in. You can try and volunteer for projects outside of your comfort zone. If you can get your boss to assign these to you, you'll be able to continue to expand your skills, and potentially work with new teams.

Remember: your boss may be responsible for your performance at your job, but you are responsible for your performance across your career.

Take on projects that both fulfill your obligation to your employer, and also position you well for your long-term career goals.

## Epilogue: You Can Do This

If there's one message I want to leave you with here, it is this: **you can do this.**

You can learn these concepts.

You can learn these tools.

You can become a developer.

Then, the moment someone hands you money for you to help them code something, you will graduate to being a professional developer.

Learning to code and getting a first developer job is a daunting process. But do not be daunted.

If you stick with it, you will eventually succeed. It is just a matter of practice.

Build your projects. Show them to your friends. Build projects for your friends.

Build your network. Help the people you meet along the way. What goes around comes around. You'll get what's coming to you.

It is not too late. Life is long.

You will look back on this moment years from now and be glad you made a move.

Plan for it to take a long time. Plan for uncertainty.

But above all, keep coming back to the keyboard. Keep making it out to events. Keep sharing your wins with friends.

As Lao Tsu, the Old Master, once said:

> "A journey of a thousand miles begins with a single step."

By finishing this book, you've already taken a step. Heck, you may have already taken many steps toward your goals.

Momentum is everything. So keep up that forward momentum you've already built up over these past few hours with this book.

Start coding your next project today.

And always remember:

You can do this.
