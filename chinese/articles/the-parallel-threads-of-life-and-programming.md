> * 原文地址：[The Parallel Threads of Life and Programming 编程与人生](https://www.freecodecamp.org/news/the-parallel-threads-of-life-and-programming-2/)
> * 原文作者：Brandon Wozniewicz
> * 译者：pjwok
> * 校对者：

![The Parallel Threads of Life and Programming](https://www.freecodecamp.org/news/content/images/size/w2000/2020/02/daria-sukhorukova-I51HSIo8k-4-unsplash.jpg)
![编程与人生](https://www.freecodecamp.org/news/content/images/size/w2000/2020/02/daria-sukhorukova-I51HSIo8k-4-unsplash.jpg)

I’m convinced our deepest desire is, by paying the cost of time, to be shown a glimmer of some fundamental truth about the universe. To hear it whisper its lessons and point towards its purpose.
通过花费了一些时间，我确信向人们展现世间万物的真理是我们内心深处的愿望。静静地聆听它们的经历指出它们的目的。

And, if you look hard enough for these lessons, you will find them. Whether they are a manifestation of your mind or can be held in your hand, once you see them, they remain yours forever.
并且，如果你努力的体会到它们的经历，你会找到答案。无论是你思想的体现还是手中握着的实物，一但你看到它们，它们会影响你一生。

Programming offers significant parallels to life. 
编程很多地方与生活有相似之处。
We are tasked with creating something–something whose sum  _feels_  more significant than the parts. 
我们的任务是创作一些东西 —— 一种整体的体验要比部分重要的多的东西。
Like life, it is a test of bounded creativity. 
就像人生，这是对有限创造力的考验。
There are rules we  _must_  follow, some we  _should_  follow, and others we are free to ignore. 
这里有一些我们必须遵守的规则，我们应该遵守的规则和其他我们可以忽略的规则。
Programming offers us a glimpse, however ephemeral it may be, into some fundamental truths about the world in which we reside.
无论多么短暂，世间真理通过编程略见一斑。




## The Four Parallels Between Programming and Life
## 编程与人生的四个平衡

### Iteration is progress.
### 迭代就是进步

Did you know, if you started the month with a single penny and it doubled every day, you would have $163 on the 15th of the month? Surely, you think, there must be a better way to make $163 in 15 days. But, if you wait another 15 days, you would have more than 5 million dollars.
你知道吗，如果你在一个月的开始拥有一分钱，并且每天它都会翻倍，你会在这个月的第15天获得163美元。当然，你想，在15天内获得163美元肯定还有别的更好的渠道。但是，如果你再等待15天，你会拥有超过5百万美元。

Go ahead, I’ll wait while you do the math.
去吧，我会等你做完计算。

In programming, we use the term  _iterate_  to indicate repeating something. In a more formal definition, it is repeatedly applying a procedure to the previous result of that procedure. For example, adding the numbers 1 and 1 to get 2, then adding 1 and 2 to get 3, and so forth.
在编程中，我们使用_迭代_这个术语去表示重复某件事。用更正式的定义，它重复地将一个过程叠加到该先前这个过程的结果上。例如，1加1等于2，然后2再加1等于3，以此类推。

When we iterate, we look for feedback. We wait for some condition to be met so we can either stop iterating or adjust  _how_  we are iterating. If we fail to listen for that feedback, we can get stuck in an infinite loop.
当我们进行迭代时，我们希望得到反馈。我们等待某些条件的满足，这样我们就可以知道是否应该停止迭代，或则调整迭代的方式。如果我们监听反馈失败了，我们会陷入无限循环中。

Life is no different. We often expect we can jump from point A to point B without ever defining what point A or point B is. And, even when we identify those points, we expect an immediate move from start to finish. Instead, what is often the truth, is we must incrementally make our way from beginning to end. We must listen for feedback that tells us where we are so we can make adjustments.
人生没有什么不同。我们总是期望从目标A跳到目标B，却从不去想目标A和目标B究竟是什么。而且，就算我们定义了这些目标，我们总是期望能够马上达成目标。相反的，真相往往是，我们必须从头到尾逐步的完成我们的目标。我们必须听取反馈，告诉我们我们在哪里，以便进行相应调整。

When we have goals, progress can often feel–for the first few days, weeks, or even months–non-existent. We’re often enticed to start over or start fresh. But in doing so, we fail to realize, while we might not have reached our destination, we are somewhere far past where we started. A complete restart isn’t necessary, we just need to make some minor adjustments.
当我们有目标，开始的几天，几个星期，几个月我们通常感受不到进步。我们经常被诱惑重头开始或者从别的新目标开始。但在这样做时，我们未能意识到，虽然我们可能尚未到达目的地，但我们已经远远超出了开始的地方。完全重新开始不是必要的，我们只需要进行一些小的调整。

Stop starting over. Let iteration be the force the creates progress.
停止重新开始。让迭代来增加进步。

### Most complex problems are collections of smaller problems that have already been solved.
### 许多复杂的问题包是由很多已经解决的小问题构成

Even the most fascinating apps are a series of mostly mundane solutions to mundane problems. In fact, most of the solutions implemented within a program are nothing unique. It is the combination of those ordinary solutions that creates an extraordinary product.
即使是体验最棒的APP也是由一系列解决普通问题的普通方案堆起来的。实际上，程序中大多数的解决方案都不是唯一的。是通过将这些普通的解决方案联系起来才诞生了一款与众不同的产品。

In programming, there are different ways to use these quite-ordinary solutions. One way is through a term called  _abstraction_. To abstract something is to move something away from something else.
在编程中，有很多种不同的形式使用这些普通的方法。其中一种在专业术语种叫做 _抽象_ 。就是从众多事物中提炼出共性。
In computer programming, when we abstract something, we are often building higher-level technology on top of lower-level technology. This makes it easier to work with lower-level technologies.
在计算机编程中，当我们抽象化某个事物，我的通常在低级技术上构建高级技术。这会让使用底层技术变得简单。

For example, most programming languages are  _abstractions_  of the enigmatic binary language (0s and 1s). They put a layer between us and some more fundamental, but cumbersome, level of interaction with the computer. These higher-level languages allow us to focus on higher-level problems.
例如，很多编程语言都是由神秘的二进制语言抽象而成（0和1）。它们在我们和计算机之间构建起了一座基本的但是复杂的桥梁。这些高级语言允许我们专注于更高层次的问题。

Another way we can more efficiently solve problems is by using someone else’s solutions. You may have also heard the term  _library_. And, while I am not speaking of a poorly lit, dusty, and quiet location where books live, it isn’t far off.
另外一种我们能有效解决问题的是使用别人用过的解决方案。你也许听过 _库_ 这个术语。在一个布满灰尘，光线暗淡，安静的地方躺着一本书，那么通常理解决问题就不远了。

A  _library_, in programming terms, is code that someone else wrote that solves routine problems. It also abstracts away those things which aren’t absolutely fundamental to solving whatever problem you have.
在编程术语中 _库_ ，是一个由别人写的为了解决某个问题的代码。它通常不是直接解决你面临的问题的方案，而是对这些问题的抽象。

For example, if you are writing a program that requires someone to log in to use your application, you  _could_  write the code to encrypt and decrypt passwords yourself,  _or,_ you could use code written by someone else to do that for you. With the latter option, we free up time to focus on more significant problems our application is trying to solve.
例如，如果你在编写需要某人登录的应用， 你 _可以_ 自己来编写加密和解密的代码，或者你也可以使用别人已经编写好的代码。通过一些设置，你可以有更多的时间去解决我们应用中更加重要的问题。

All of us use abstractions and libraries in some shape or form. For example, the grocery store is an abstraction of producing our own food. A car is an abstraction of traveling on foot. An oven is an abstraction of building a fire. These are layers we place in front of us that allows us to allocate time to higher-level problems.
我们所有人都在某种形式中使用抽象和库。例如，杂货店是对我们生产食物的抽象。汽车是徒步旅行的抽象。烤箱是生火的抽象。这些摆在我们面前的东西可以帮助我们分配更多的时间给更高级的问题。

Reinvent the wheel only to learn how to make a wheel, not to drive to the store.
重新造轮子只是为了学习怎么去制造一个轮子，而不是开着它去商店。


### How you define a problem is how you will solve it.
### 你如何看待问题你会如何解决它

Recall the story of a truck that drove under a bridge and got stuck. Engineers spent hours trying to figure out how to move the bridge. A small child came up, face to face with the tires of the truck, and said, “what if you let the air out of the tires?”
回想一下一辆卡车在桥下行驶并被卡住的故事。工程师需要花费数小时想办法将卡车弄出桥。一个小孩出现了，站在卡车轮胎前，说到：“可以把轮胎的气放掉吗？”

From the child’s vantage point, the problem wasn’t the bridge was too short, but rather the truck was too tall.
从孩子的角度出发，问题不是桥太矮了，而是卡车太高了。

Most people can solve any problem. In fact, most problems state the solution. For example, if the bridge is causing the issue, the answer is to do something with the bridge. If, however, the problem is that the truck is too tall, then the solution–almost glaringly obvious–is to make the truck shorter.
许多人可以解决任何问题。实际上，许多问题都有解决办法。例如，如果桥出现了问题，那么答案肯定是对桥要做些什么。当然，如果问题是卡车太高了，那么解决方案显而易见是让卡车变矮。

### The arrangement of parts is much more important than the parts themselves.
### 整体比部分更重要

What does the Google Maps codebase, the Declaration of Independence, Martin Luther King Jr.’s  _I have a dream_  speech, Steve Jobs’s 2005 commencement address, and my first app,  _Hello, World_  have in common?
谷歌地图代码库，《独立宣言》，马丁路德金《我有一个梦想》的演讲，2005年史蒂夫乔布斯的开始的地址，以及我的第一个应用 _Hello World_ 这些有什么共同点？

The access to the same 26 letters of the English alphabet.
它们都是拼接英语字母表中相同的26个字母。

There is very little that is more fascinating to me than the written word. The written word is one of the most powerful  _technologies_  that emerged from humans.
没有什么比书面文字更让我着迷了。书面文字是人类诞生到现在最强大的 _技术_ 之一。

Yes, I use the term  _technology_ because–even carved into the wall of a cave–it fundamentally changed how we persist information. No longer was data constrained within the boundaries of our minds.
是的，我使用 _技术_ 这个词，因为 —— 即使是刻在洞穴上的壁画 —— 它们从根本上改变了我们保留信息的方式。数据不在受我们大脑的约束。

While the purpose of the written word was initially linked to record-keeping, it quickly became a way to spread ideas. Some of these ideas would anger, and others inspire.
虽然记录文字最初目的是保存记录，但它会马上成为一种传播思想的方式。其中一些想法会令人愤怒，而另一些会让人受到启发。

Every language (including computer language) has subtleties when transmitting information through writing or speech. The words and their constituent parts may be slightly different. Still, however, a language is a set of symbols that can be arranged into what seems to be an infinite number of ideas.
每种语言（包括计算机语言）在通过书写或语言传送信息时在细微之处都有略微不同。每个单词及其组成部分也略微不同。但是，语言仍然是一组符号，可以将其组合成近乎无限的思想。  

For example, in the English language, there are roughly 29 symbols that I can use to represent nearly my entire universe. I’ve mentioned the 26 letters, but it is also helpful to have access to periods, commas, and question marks.
例如，在英语中，我可以用大约29种符号来表达几乎整个宇宙。我已经提到了26个字母，但是句号，逗号，问号这些也同样有帮助。

Those 29 characters are available to you, me, and were available to Steve Jobs. Yet, each of us, throughout our lives, will follow different trajectories based on the combination of letters we chose to believe and speak into existence.
这29个符号对于你，我还有史蒂夫乔布斯都很有价值。然而，我们每个人的一生，基于我们选择相信的文字和语言，都会遵循不同的轨迹。

Interestingly, while we often add words to the dictionary, we don’t usually add letters. This means, at the most fundamental level, that all the ideas that can exist, already do, with their constituent parts quietly waiting for us to shuffle them into existence.
有趣的是，虽然我们经常在字典中添加单词，但是我们通常不会添加字母。这就意味着，在最基本的层面上，所有可能存在的想法都已经存在，正在静静等待我们去发现它们的存在。

**_Les Brown_  sums it up well with this thought experiment:**
**_Les Brown_ 通过下面几个实践很好的进行了总结：**

_Imagine if you will, being on your death bed. And standing around your bed–the ghosts of the ideas, the dreams, the abilities, the talents given to you by life._
_想象一下，假如你临死时躺在病床上。站在你床周围的是生活中赋予你思想，梦想，能力和才华的灵魂。_

_And that you, for whatever reason, never acted on those ideas. You never pursued that dream. You never used those talents. We never saw your leadership. You never used your voice. You never wrote that book._
但是由于你出于某些原因从未对这些想法采取过行动。你从未追寻过那个梦想。你从未使用过这些才能。我们从未见过你的领导力。你从来没有为自己发声。你从未写过那本书。

_And there they are, standing around your bed, looking at you with large angry eyes saying: “We came to you. And only you could have given us life! Now we must die with you forever.”_
现在它们就站在你的床边，并用愤怒的目光瞪着你说： “我们为你而来。只有你能给我们生命。现在我们必须要和你一起死去”

_The question is — if you die today–what ideas, what dreams, what abilities, what talents, what gifts, would die with you?_
_问题是 ——  如果你今天就死了，在你临死时什么思想，梦想，能力，天赋，礼物是你想一起带走的？_

Thank you for reading!
谢谢你的阅读！