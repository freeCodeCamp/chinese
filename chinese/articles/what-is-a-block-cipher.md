> -  原文地址：[Cipher Definition – What is a Block Cipher and How Does it Work to Protect Your Data?](https://www.freecodecamp.org/news/what-is-a-block-cipher/)
> -  原文作者：[Megan KaczanowskiMegan Kaczanowski](https://www.freecodecamp.org/news/author/megansdoingfine/)
> -  译者：luojiyin
> -  校对者：

![密码的订阅-什么是区块密码，它是如果保护你的数据](https://www.freecodecamp.org/news/content/images/size/w2000/2021/06/block-and-stream-cipher.jpg)

密码学是使用代码和密码来保护信息的学科。加密涉及对信息进行编码，以便预定的接收者能够知道信息的含义。它经常被用来保护传输的数据。

加密是一个双向的功能-也就是说，你能消除任何对信息进行扰乱。

今天，有两种基本类型的基本算法-对此和非对称。

对此算法也被称为`secret key`(秘钥) 算法，而非对称算法则被称为`public key`(公钥)算法。

两者的关键区别在于，对称算法使用相同的密钥进行加密和解密，而非对称算法使用不同的密钥进行加密和解密。

关于密码学的一般概述以及对称和非对称密码的区别，请查看[本文](/news/how-to-send-secret-messages/).

## 当你开发一个密码时，哪些原则时重要的？

克尔克霍夫原则指出，一个加密系统应该是安全的，即使所有的细节(key除外)都是公开的。克劳德-香农后来将这一说成 `敌人知道系统`。

从本质上讲，一个设计得非常好得系统应该能够发送加密信息，即使攻击者能使用相同得算法(用不同得密钥)加密和解密自己的消息。加密信息的安全性应该完全取决于密钥。

此外，为了阻碍统计分析(试图破解加密算法)，一个好的密码系统应该采用混乱和扩散的原则。

混乱要求密钥不能以简单的方式与加密后产生的文本相关联性。加密后产生的文本的每个字符都应取决于密钥的多个部分。其目的是使攻击者很难从加密后产生的文本中确定密钥。

扩散的意思是，如果明文中的一个字符被改变，那么加密后产生的文本中几个字符也应该改变。如果加密后产生的文本中一个字符改变，那么明文中的几个字符也应该改变。

理想情况下，加密后产生的文本和明文之间的关系是隐藏的。没有任何扩散是完美的(都会有一些模式)，但最好的扩散是将模式广泛扩散，甚至是几个模式一起使用。

扩散使攻击者难以发现模式，并要求攻击者拥有更多的数据，以发起成功的攻击。

如果你想多读一点这方面的内容，可以查看[密码学的数学理论](https://www.iacr.org/museum/shannon/shannon45.pdf).

## 什么是块和流加密(Stream Ciphers)？

块和流加密都是对称密钥密码(如DES、RCx、Blowfish和Rijndael AES)。块加密将明文逐块转换为密文，而流加密则每次转换为一个字节。

大多数现代对称算法都是`block ciphers`(块加密)，尽管块大小不同(如EDS(64位)，AES(128,192和256位)，等等)。

### 流加密的优势是什么？

流加密的速度更快(时间上是线性的)，在空间上是恒定的。它不太可能发生传输错误，因为一个字节的转换错误不会影响下一个字节。

当明文的数量未知时(如音频或视频流)，或者极端的性能要求下(如非常高速的连接，或者需要非常有效的和紧凑的设备，如智能卡)，你通常会使用流加密。

流加密的工作原理是由密钥生成一系列的伪随机字节(对于给定的密钥，加密和解密过程中的使用相同的伪随机字节)。不同的密钥会产生不同的字节串。

为了加密数据，明文字节与伪随机字节串进行XOR(异或操作)。为了解密，将加密后产生的文本与相同的伪随机字节串进行XOR(异或操作)，就可以看到明文。

### 块加密的优势是什么？

块加密有很高的扩散性(一个明文符合被扩散到几个密码文本符号中)。攻击者要插入符号而不被发现是很困难的，因为他们不可能轻易将符号插入到块的中间。

然而，它比流加密慢(加密/解密之前需要传输整个块)，如果发生错误，它可以传染到这个块，破坏整个块。

当你知道传输数据规模时，块加密是一个更好的选择，例如在传输文件。

## 块加密的常见模式是什么？

为了对多块的数据进行加密，有几种`模式`已经被开发出来。这些模块将单块原则用于更长的消息。

块加密有5种保密模式。其中一些模式需要一个初始化向量(IV) 才能发挥作用。

###  什么是Initialization Vector (IV  初始化变量)?

IV的本质只是用于创建密文的另一个输入(除了明文和密钥)。它是一个数据块，被几种模式的块加密用来随机化加密，这样即使相同的明文被重复加密，也会产生不同的密文。

它通常不是秘密，尽管它不会被重复使用。在理想情况下，它应该是随机的，不可预测和一次性使用。

两个相同的信息用相同的密钥加密，但不同的IV，将导致不同的密文。 这使进行攻击更加困难。

### Electronic Code Book Mode (ECB 电子代码本模式)

在明文的输入块和密文输出块有一个固定的映射(基本上就像一个实际的密码本，密文的字与明文直接相关)。

ECD对每个明文块应用加密函数进行加密(对每个密文块应用逆向函数进行解密)。这意味着CBC可以并行地加密和解密多个块(因为它们相互不依赖)，加快了处理进程。

![](https://megankaczanowski.com/content/images/2020/12/Screen-Shot-2020-12-31-at-8.22.20-PM.png)

https://en.wikipedia.org/wiki/Block\_cipher\_mode\_of\_operation

要使这种模式正常工作，要么信息长度是块大小的整数倍，要么你需要使用填充来满足长度条件。

填充实质上为了满足块大小而添加的额外数据。在这种模式下，给定相同的密钥，相同的明文块将总是导致相同的密文块。这是它很容易受到攻击，所以这种模式很少使用(应该避免使用)。
### Cipher Block Chaining Mode (CBC  加密块链模式)

这种加密模式将新的明文块与前一个加密区`关联(chains)`或者结合起来，这需要为第一个块提供一个IV。IV不需要加密，但它要不可预测。

CBC将第一个明文块与IV密文块进行XOR(异或)，以创建第一个密文块。使用ECB模式将IV作为一个短消息单独发送。

然后，CBD对该块使用加密算法，产生第一个密文块。然后，CBC将此密文块与第一个文明块进行XOR(异或)，并应用加密算法产生第二个密文块，如果反复，直到消息的最后。

为了解密，CBC做了想法的工作--第一个密文块使用反向的加密算法，然后将该块与IV进行XOR(异或),得到第一个明文块。

然后，CBC将加密算法的逆运算应用于第二个密文块，并将该块与第一密文块进行XOR，得到第二个明文块。这个过程将一直持续到消息被解密。

![](https://megankaczanowski.com/content/images/2020/12/Screen-Shot-2020-12-31-at-8.22.37-PM.png)

https://en.wikipedia.org/wiki/Block\_cipher\_mode\_of\_operation

因为每个输入块(除了第一个)都依赖于前一个块被加密，CBC不能并行地进行加密。然而，由于解密需要(立即可用)密文块进行XOR，所以它可以并行进行。CBC是最常用的模式之一。

于ECB相似，要使用这种模式正常工作，消息的长度需要是块大小的两倍，不足要进行填充来满足长度。

### Cipher Feedback Mode (CFB 加密反馈模式)

CFB与CBC相似，但CFB不是使用整个前一个密文块计算下一个块，而是前一个块的一部分。

1 CFB从一个与加密块预期大小相同的IV开始，使用加密算法对其进行加密。

2 CFB保留`s`(重要)字节，并将其与要传输的明文`s`字节进行XOR(异或)。

3 然后，CFB将IV的`s`字节向左移动，将步骤2 产生的密文字节插入右边的字节中(IV保持相同的长度)。

4 然后重复这些步骤。

为了解密消息，CFB使用IV作为第一个块，并通过执行上述步骤3和应用加密算法形成块形成每个后续块。然后，CFB与 `s`字节相应的密文进行XOR(异或)，以显示明文。

在CFB内部，加密系统一次处理 `s < b`明文位，即使算法本身进行 `b-bits`到 `b-bits`的转换。这意味着s 可以是任何数字，包含一个1个字节，CFP可以在流加密中作为一个功能运行。

![](https://megankaczanowski.com/content/images/2020/12/Screen-Shot-2020-12-31-at-8.24.31-PM.png)

https://en.wikipedia.org/wiki/Block\_cipher\_mode\_of\_operation

不幸的是，这意味着CFB可以向下游传播错误。如果收到一个错误的字节，当CFB用它来解密第一个字节时，它将产生一个错误的解密，导致后面的解密错误。

像CBC一样，当CFB加密时，每轮的输入都依赖于前一轮的结果，这意味着加密不能并行进行，尽管如果输入块首先由IV和密文创建，则可以并行进行解密。

### Output Feedback (OFB  输出反馈)

OFB与CFB类似，但它不是将 `s<b` 位处理转换成 ` b-bits to b-bits`，而是直接`s`位处理。与CFB类似，OFB可以在流加密中使用。

OFB要求IV是唯一的nonce(一次性使用)，用于给定的密钥每次执行。

首先，OFB加密算法对IV进行加密，产生一个块。然后，OFB将此块与一个明文块进行XOR,产生第一密文块。

OFB用加密算法对第一个输出块进行加密，输出第二个输出块。然后，它将此块与第二个明文块进行XOR(异或)，产生第二个密文块。OFB在信息的长度上重复这一过程。

![](https://megankaczanowski.com/content/images/2020/12/Screen-Shot-2020-12-31-at-8.22.54-PM.png)

https://en.wikipedia.org/wiki/Block\_cipher\_mode\_of\_operation

解密时，OFB用加密算法对IV进行加密，产生一个输出块。然后OFB将此块与第一个密文块进行XOR(异或),恢复第一个明文块。

OFB用加密算法对第一个输出块进行加密，产生第二个输出块。然后OFB将其与第二个密文块进行XOR，恢复第二个明文块。OFB为信息的长度重复这一过程。

由于用于解密的输出块是本地生成的，OFB比CFB更能抵抗传输错误。

### Counter (CTR 计算器)

CTR将加密算法应用于一组独特的输入块（计数器），以产生输出，这些输出与明文进行XOR(异或)以产生密码文本。

CTR用加密算法对第一个计数器进行加密，然后将产生的输出与第一个明文块进行XOR，产生第一个密文块。CTR对每个区块重复这一过程（有一个新的计数器--计数器在使用单一密钥加密的所有信息中必须是唯一的）。

如果最终的块是一个`s`字节的部分块(输出块的最重要的位)，`s`被用于XOR，而输出块的`b-s`字节被丢弃。

![](https://megankaczanowski.com/content/images/2020/12/Screen-Shot-2020-12-31-at-8.23.02-PM.png)

https://en.wikipedia.org/wiki/Block\_cipher\_mode\_of\_operation

解密也遵循同样的模式。CTR用加密算法对计数器进行加密，然后将输出与相应的密文块进行XOR，产生明文块。

如果最终的块是一个`s`字节的部分块(那么输出块的最重要的比特)。s，被用于XOR，而输出块的`b-s`字节被丢弃。

CTR已被证明至少与其他四种模式一样安全，同时还能够并行执行（包括加密和解密），这意味着它非常快。

如果可以确定每个区块的计数器区块，并且可以在收到明文或密文之前对计数器进行加密（如果内存不受限制），那么每个区块都可以独立恢复。

更多请阅读: [NIST Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)

## 攻击者如何试图破解加密?

攻击者使用的技术有很多，但根据实施攻击所需的信息，它们大致可分为以下几类。

这并不是一个详尽的清单（还有其他攻击，如侧信道攻击），但许多最常见的攻击都属于这些类别之一。

### 已知密文攻击

攻击者拥有一些密码文本，但不知道用什么明文来生成这个密码文本。攻击者不能选择他们所拥有的密码文本，他们也不能获得/产生更多的密码文本。

这是最容易尝试的攻击类型，因为窃听加密对话是最容易的（因为假定进行对话的人使用强大的加密技术，并不担心窃听者）。但这是最难成功的，只要发送信息的人使用适当的强加密。

_例如: David 发现一个加密信息 (密文) 在[死角](https://en.wikipedia.org/wiki/Dead_drop#:~:text=A%20dead%20drop%20or%20dead,individuals%20can%20maintain%20operational%20security.)，但不知道这条消息是什么意思。_

### 已知明文攻击

攻击者拥有一些他们没有选择的明文和密文对（所以攻击者没有选择被加密的信息，但能够成功窃取明文信息和其相关的密文）。攻击者不能获得/产生更多的相关信息。

_例如，大卫发现了一个敌方间谍的藏身之处，并在间谍发送加密信息时打断了他。这个间谍傻乎乎地逃走了，留下了明文信息和其相关的密码文本的记录。_

### 选定明文攻击

攻击者可以选择任何明文并获得密文(但他们不能看到密钥本身)。

这进一步细分为批量选择的明文（攻击者可以提交一组明文并收到密文，但不能再次这样做）和调整选择的明文（攻击者可以提交明文，并根据以前的密码文本提交额外的明文，获得新的密文）。

_例如：民族国家A正在窃听另一个民族国家B的加密通信，并且知道A和B所有的加密都使用同一个密钥。A和B向另一个民族国家C发送了一份敏感的外交通讯，知道它将通过加密通道传输，从而给他们提供了一个选定的明文--密文对。_

### 选定密文攻击

这与上一种攻击相反，攻击者可以选择任何密码文本并获得明文作为回报（但他们不能看到密钥本身）。

_比如说：David 知道敌方间谍明天要发送一份加密信息，所以他用自己选择的密文替换原密文，然后监视收件人，听他们读出信息的明文。 _

### 资料来源/更深入阅读:

-   [NIST Recommendations for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)
-   [Diffusion and Confusion](https://www.nku.edu/~christensen/diffusionandconfusion)
-   [Confusion and Diffusion](https://en.wikipedia.org/wiki/Confusion_and_diffusion)
-   [Kerckhoffs's Principle](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle)
-   [Padding Mechanisms](http://www.crypto-it.net/eng/theory/padding.html)
-   [Foundations of Computer Science: Stream and Block Encryption](https://www.cs.utexas.edu/~byoung/cs361/lecture45.pdf)